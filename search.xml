<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle学习4-子查询]]></title>
    <url>%2F2019%2F11%2F18%2Foracle%E5%AD%A6%E4%B9%A04-%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[子查询 所谓子查询，实际上为查询的嵌套当根据给出的条件无法直接查出所需要的数据时,需要用到子查询. 子查询出现的位置其中出现子查询最多的位置: where from 1用在where之后,作为条件判断; 查询与7369同部门的所有人 12345678910111213SQL&gt; select empno,ename,deptno 2 from emp 3 where deptno= 4 (select deptno from emp where empno=7369); EMPNO ENAME DEPTNO---------- -------------------- ---------- 7777 S_HH%GGH 20 7369 SMITH 20 7566 JONES 20 7788 SCOTT 20 7876 ADAMS 20 7902 FORD 20 2用在select之后,作为select的内容; 查询每个部门的人数 123456789SQL&gt; select 2 (select count(1) from emp where deptno=10) &quot;10&quot;, 3 (select count(1) from emp where deptno=20) &quot;20&quot;, 4 (select count(1) from emp where deptno=30) &quot;30&quot; 5 from dual; 10 20 30---------- ---------- ---------- 3 6 6 3可以用在having之后,用作分组数据判断的条件 查询平均工资 少于20组的平均工资 的班组 123456789SQL&gt; select deptno, avg(sal) 2 from emp 3 group by deptno 4 having avg(sal) &gt; 5 (select avg(sal) from emp where deptno = 20); DEPTNO AVG(SAL)---------- ---------- 10 2916.66667 4用在from之后,作为一个结果集: 查询最高工资的的五人的成绩 1234567891011SQL&gt; select * 2 from (select sal from emp where sal &gt; 0 order by sal desc) 3 where rownum &lt; 6; SAL---------- 5000 3000 3000 2975 2850 子查询的使用方式1子查询返回单行单列要求查询公司工资最低的员工姓名,班组信息 第一步：统计出公司的最低工资 12345SQL&gt; select min(sal) from emp; MIN(SAL)---------- 800 第二步:上面会返回单行单列数据，是一个数值.再进行where条件判断 123456SQL&gt; select ename,job,deptno from emp 2 where sal=(select min(sal) from emp);ENAME JOB DEPTNO-------------------- ------------------ ----------SMITH CLERK 20 查询公司雇佣最早的雇员 雇佣最早一定是雇员日期最小，那么使用MIN()函数完成 12345SQL&gt; select min(hiredate) from emp;MIN(HIREDATE)--------------17-12月-80 返回单行单列的数据，所有可以直接在WHERE子句中使用 123456SQL&gt; select empno,ename,hiredate from emp 2 where hiredate=(select min(hiredate) from emp); EMPNO ENAME HIREDATE---------- -------------------- -------------- 7369 SMITH 17-12月-80 2子查询返回单行多列查询出与SMITH部门相同、职位相同的所有雇员的编号姓名信息 首先应该查询SMITH的部门与职位 123456SQL&gt; select deptno,job from emp 2 where ename=&apos;SMITH&apos;; DEPTNO JOB---------- ------------------ 20 CLERK 此时返回了单行两列的数据信息，要进行比较时要同时满足 123456789SQL&gt; select empno,ename,deptno,job from emp 2 where (deptno,job)=( 3 select deptno,job from emp where ename=&apos;SMITH&apos;); EMPNO ENAME DEPTNO JOB---------- -------------------- ---------- ------------------ 7777 S_HH%GGH 20 CLERK 7369 SMITH 20 CLERK 7876 ADAMS 20 CLERK 3子查询返回多行多列 在WHERE子句中提供有三个主要的运算符：IN、ANY、ALL 123456789101112SQL&gt; select * from sc;SNO CNO SCORE-------------------- -------------------- ----------s001 c001 78.9s002 c001 80.9s003 c001 81.9s004 c001 60.9s001 c002 82.9s002 c002 72.9s003 c002 81.9s001 c003 59 查询c001课程比c002课程成绩高的所有学生的学号 12345678910SQL&gt; select sno 2 from sc t1 3 where t1.cno=&apos;c001&apos; 4 and sno in 5 (select sno from sc where 6 cno=&apos;c002&apos; and t1.score&gt;score and t1.sno=sno);SNO--------------------s002 4exists 用于检查子查询是否至少返回一行数据 该子查询实际上并不返回任何数据,而是返回值True和False 查询c001课程比c002课程成绩高的所有学生的学号 12345678910SQL&gt; select sno 2 from sc t1 3 where t1.cno=&apos;c001&apos; 4 and exists( 5 select * from sc where 6 cno=&apos;c002&apos; and t1.sno=sno and t1.score&gt;score);SNO--------------------s002 补充:排序函数12345678910111213SQL&gt; select * from sc;SNO CNO SCORE-------------------- -------------------- ----------s001 c001 78.9s002 c001 80.9s003 c001 81.9s004 c001 60.9s001 c002 82.9s002 c002 72.9s003 c002 81.9s001 c003 59s004 c002 81.9 rank() over 查出指定条件后的进行排名 使用这个函数，成绩相同的两名是并列，下一位同学空出所占的名次。 查询各科成绩前三名的记录 1234567891011121314SQL&gt; select cno,sno,score, 2 rank() over(partition by cno order by score desc) ranks from sc;CNO SNO SCORE RANKS-------------------- -------------------- ---------- ----------c001 s003 81.9 1c001 s002 80.9 2c001 s001 78.9 3c001 s004 60.9 4c002 s001 82.9 1c002 s003 81.9 2c002 s004 81.9 2c002 s002 72.9 4c003 s001 59 1 12345678910111213SQL&gt; select cno,sno,score from 2 (select cno,sno,score,rank() over(partition by cno order by score desc) rank from sc) 3 where rank&lt;4;CNO SNO SCORE-------------------- -------------------- ----------c001 s003 81.9c001 s002 80.9c001 s001 78.9c002 s001 82.9c002 s003 81.9c002 s004 81.9c003 s001 59 使用rank over()的时候，空值是最大的，如果排序字段为null, 可能造成null字段排在最前面，影响排序结果。 12345678910111213SQL&gt; select deptno,comm, 2 dense_rank() over(partition by deptno order by comm desc) ranks 3 from emp 4 where deptno=30; DEPTNO COMM RANKS---------- ---------- ---------- 30 1 30 1 30 1400 2 30 500 3 30 300 4 30 0 5 12345678910111213SQL&gt; select deptno,comm, 2 dense_rank() over(partition by deptno order by comm desc nulls last) ranks 3 from emp 4 where deptno=30; DEPTNO COMM RANKS---------- ---------- ---------- 30 1400 1 30 500 2 30 300 3 30 0 4 30 5 30 5 dense_rank() over 与rank() over的区别是:两名学生的成绩并列以后，下一位同学并不空出所占的名次。 1234567891011121314SQL&gt; select cno,sno,score, 2 dense_rank() over(partition by cno order by score desc) ranks from sc;CNO SNO SCORE RANKS-------------------- -------------------- ---------- ----------c001 s003 81.9 1c001 s002 80.9 2c001 s001 78.9 3c001 s004 60.9 4c002 s001 82.9 1c002 s003 81.9 2c002 s004 81.9 2c002 s002 72.9 3c003 s001 59 1 1234567891011121314SQL&gt; select cno,sno,score from 2 (select cno,sno,score,dense_rank() over(partition by cno order by score desc) rank from sc) 3 where rank&lt;4;CNO SNO SCORE-------------------- -------------------- ----------c001 s003 81.9c001 s002 80.9c001 s001 78.9c002 s001 82.9c002 s003 81.9c002 s004 81.9c002 s002 72.9c003 s001 59 row_number 该函数不需要考虑是否并列，那怕根据条件查询出来的数值相同也会进行连续排名 1234567891011121314SQL&gt; select cno,sno,score, 2 row_number() over(partition by cno order by score desc) ranks from sc;CNO SNO SCORE RANKS-------------------- -------------------- ---------- ----------c001 s003 81.9 1c001 s002 80.9 2c001 s001 78.9 3c001 s004 60.9 4c002 s001 82.9 1c002 s003 81.9 2c002 s004 81.9 3c002 s002 72.9 4c003 s001 59 1 12345678910111213SQL&gt; select cno,sno,score from 2 (select cno,sno,score,row_number() over(partition by cno order by score desc) ranks from sc) 3 where ranks&lt;4;CNO SNO SCORE-------------------- -------------------- ----------c001 s003 81.9c001 s002 80.9c001 s001 78.9c002 s001 82.9c002 s003 81.9c002 s004 81.9c003 s001 59]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle子查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习2-集合关联查询]]></title>
    <url>%2F2019%2F11%2F17%2Foracle%E5%AD%A6%E4%B9%A02-%E9%9B%86%E5%90%88%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[集合 使用前提：两个集合必须有相同的列数,相同的列属性(数据类型,长度). 集合 关键字 五种运算 描述 并集 union all A union all B 取两个集合中所有的元素,不去除重复元素 union A union B 取两个集合中的所有元素,去掉重复元素 交集 intersect A intersect B 取两个集合重复部分的元素 差集合 minus A minus B A集合中的元素减去两个集合交叉部分的元素 B minus A B集合中的元素减去两个集合交叉部分的元素 union 显示两个集合的合集,并去掉重复部分,并按照从小到大自动排序;12345678910SQL&gt; select * from test1 2 union 3 select * from test2; ID NAME---------- ------ 1 A 2 B 3 C 4 D union all 显示两个集合的合集,不去重123456789101112SQL&gt; select * from test1 2 union all 3 select * from test2; ID NAME---------- ------ 1 A 2 B 3 C 1 A 2 B 4 D minus:显示差集,显示第一个集合的数据去掉两个集合的合集部分1234567SQL&gt; select * from test1 2 minus 3 select * from test2; ID NAME---------- ------ 3 C 1234567SQL&gt; select * from test2 2 minus 3 select * from test1; ID NAME---------- ------ 4 D intersect:显示两个集合的交集12345678SQL&gt; select * from test1 2 intersect 3 select * from test2; ID NAME---------- ------ 1 A 2 B 关联查询 定义: 当需要的数据在两张表或者多张表中时,需要用到关联查询 语法:关联查询使用到多张表时,from之后的表名用逗号隔开, where条件中必须有两个表关联的条件,实现关系传递. 准备数据 1234567891011121314create table TEST1(id number(5),name varchar2(3));insert into TEST1 values(1,&apos;A&apos;);insert into TEST1 values(2,&apos;B&apos;);insert into TEST1 values(3,&apos;C&apos;);commit;create table TEST2 as select * from TEST1;update TEST2 set ID=4, name=&apos;D&apos; where id=3;commit; 1234567SQL&gt; select * from test1; ID NAME---------- ------ 1 A 2 B 3 C 1234567SQL&gt; select * from test2; ID NAME---------- ------ 1 A 2 B 4 D 1内连接根据条件将两张表的数据连接起来 如果没有符合条件的数据都会被过滤掉(会过滤掉两个表中的部分数据) 关键字:inner joininner是可以省略的 1234567891011121314151617SQL&gt; select * 2 from test1 t1 inner join test2 t2 3 on t1.id=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 BSQL&gt; select * 2 from test1 t1 join test2 t2 3 on t1.id=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 也可以写为 12345678SQL&gt; select * 2 from test1 t1,test2 t2 3 where t1.id=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 查找员工编号为7521的人所在部门的全部信息 emp,dept 1234567SQL&gt; select * from dept a join emp b 2 on a.deptno=b.deptno 3 and b.empno=7521; DEPTNO DNAME LOC EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- ---------------------------- -------------------------- ---------- -------------------- ------------------ ---------- -------------- ---------- ---------- ---------- 30 SALES CHICAGO 7521 WARD SALESMAN 7698 22-2 月 -81 1250 500 30 12345678SQL&gt; select * 2 from dept a, emp b 3 where b.empno = 7521 4 and a.deptno = b.deptno; DEPTNO DNAME LOC EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- ---------------------------- -------------------------- ---------- -------------------- ------------------ ---------- -------------- ---------- ---------- ---------- 30 SALES CHICAGO 7521 WARD SALESMAN 7698 22-2 月 -81 1250 500 30 2自连接 内连接的一种特殊形式,没有自己的关键字一张表和它自己进来连接 查询员工姓名并查询员工的上级名称 1234567891011SQL&gt; select p1.ename,p2.ename 2 from emp p1 join emp p2 3 on p1.mgr=p2.empno;ENAME ENAME-------------------- --------------------FORD JONESSCOTT JONESALLEN BLAKEWARD BLAKEJAMES BLAKE 也可以写为 1234567891011SQL&gt; select p1.ename,p2.ename 2 from emp p1,emp p2 3 where p1.mgr=p2.empno;ENAME ENAME-------------------- --------------------FORD JONESSCOTT JONESALLEN BLAKEWARD BLAKEJAMES BLAKE 3不等连接 连接条件是不等关系的连接 查询员工编号,姓名 并显示员工的工资等级 123456789SQL&gt; select * from salgrade; GRADE LOSAL HISAL---------- ---------- ---------- 1 700 1200 2 1201 1400 3 1401 2000 4 2001 3000 5 3001 9999 1234567891011121314151617181920SQL&gt; select p1.empno,p1.ename,s1.grade 2 from emp p1 join salgrade s1 3 on p1.sal between s1.losal and s1.hisal; EMPNO ENAME GRADE---------- -------------------- ---------- 7369 SMITH 1 7900 JAMES 1 7876 ADAMS 1 7521 WARD 2 7654 MARTIN 2 7934 MILLER 2 7844 TURNER 3 7499 ALLEN 3 7782 CLARK 4 7698 BLAKE 4 7566 JONES 4 7902 FORD 4 7788 SCOTT 4 7839 KING 5 查询比每个人工资低的人数 123456789101112131415SQL&gt; select p1.empno, p1.ename, p1.sal, count(*) 2 from emp p1 join emp p2 3 on p1.sal &gt; p2.sal 4 group by p1.empno, p1.ename, p1.sal; EMPNO ENAME SAL COUNT(*)---------- -------------------- ---------- ---------- 7566 JONES 2975 10 7698 BLAKE 2850 9 7521 WARD 1250 3 7654 MARTIN 1250 3 7876 ADAMS 1100 2 7782 CLARK 2450 8 7788 SCOTT 3000 11 7839 KING 5000 13 查看比员工: ALLEN工资低的员工信息 123456789101112131415SQL&gt; select p1.empno, p1.ename, p1.sal, 2 p2.empno, p2.ename, p2.sal 3 from emp p1 join emp p2 4 on p1.sal&gt;p2.sal 5 where p1.ename=&apos;ALLEN&apos;; EMPNO ENAME SAL EMPNO ENAME SAL---------- ----------- ---------- ---------- ----------------- ---------- 7499 ALLEN 1600 7369 SMITH 800 7499 ALLEN 1600 7521 WARD 1250 7499 ALLEN 1600 7654 MARTIN 1250 7499 ALLEN 1600 7844 TURNER 1500 7499 ALLEN 1600 7876 ADAMS 1100 7499 ALLEN 1600 7900 JAMES 950 7499 ALLEN 1600 7934 MILLER 1300 1全(外)连接 关键字:full outer joinouter:可以省略 会查出两张表的所有数据 根据关系列进行等值连接 如果一张表中的数据,根据连接条件在另一张表中找不到相应的数据时,他会在相应的位置显示为空 12345678910SQL&gt; select t1.*,t2.* 2 from test1 t1 full join test2 t2 3 on t1.id=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 4 D 3 C 2左(外)连接 关键字:left outer joinouter:可以省略 左连接是把左表的所有数据查询出来 会根据连接条件去右表中找和它对应的数据 如果找到就连接为一条数据,如果找不到就只显示左表的数据.右表部分显示为空(左连接会过滤掉右表中的部分数据) 123456789SQL&gt; select t1.*,t2.* 2 from test1 t1 left join test2 t2 3 on t1.id=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 3 C 左连接的又一写法 123456789SQL&gt; select t1.*,t2.* 2 from test1 t1,test2 t2 3 where t1.id=t2.id(+); ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 3 C 3右(外)连接 右连接会查出所有右表的数据,根据连接条件去左表找对应的数据,如果找到就连接起来 如果找不到,就显示为空 右连接会过滤掉部分左表的数据 123456789SQL&gt; select t1.*,t2.* 2 from test1 t1 right join test2 t2 3 on t1.id=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 4 D 右连接的又一写法 123456789SQL&gt; select t1.*,t2.* 2 from test1 t1,test2 t2 3 where t1.id(+)=t2.id; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 2 B 2 B 4 D 自然连接和交叉连接1自然连接 关键字natural join 自然连接会从两张表中找到列名相同的列进行等值连接 如果在两张表中找不到关系列值相等的数据,这样的数据会被过滤掉 1234567SQL&gt; select * 2 from test1 t1 natural join test2 t2; ID NAME---------- ------ 1 A 2 B 2交叉连接 关键字:cross join 拿表1中的一条数据和表2的所有数据依次进行连接然后再拿表1第二条数据和表2的所有数据依次进行连接以此类推排查出所有结果交叉连接的结果条数,是第一张表的数据条数,乘以第二张表的数据条数 1234567891011121314SQL&gt; select * 2 from test1 t1 cross join test2 t2; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 1 A 2 B 1 A 4 D 2 B 1 A 2 B 2 B 2 B 4 D 3 C 1 A 3 C 2 B 3 C 4 D 交叉连接又一写法 1234567891011121314SQL&gt; select * 2 from test1 t1,test2 t2; ID NAME ID NAME---------- ------ ---------- ------ 1 A 1 A 1 A 2 B 1 A 4 D 2 B 1 A 2 B 2 B 2 B 4 D 3 C 1 A 3 C 2 B 3 C 4 D]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle集合</tag>
        <tag>oracle关联查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习3-常用函数]]></title>
    <url>%2F2019%2F11%2F11%2Foracle%E5%AD%A6%E4%B9%A03-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1常用函数汇总 定义,封装好一段代码,会返回指定的结果 数值型函数 序号 数值型函数 描述 1 abs(x) 绝对值 2 sign(x) 正负值 3 ceil(x) 返回大于等于x的最小整数值 4 floor(x) 返回小于等于x的最大整数值 5 power(x,y) 返回x的y次幂 6 log(x,y) 返回以x为底的y的对数,即log(底,数值) 7 mod(x,y) 取余 8 round(x[y]) 返回按精度y四舍五入后的值 9 trunc(x[y]) 返回按精度y截取后的值 10 sqrt(x) 返回x的平方根 字符型函数 序号 字符型函数 描述 1 ascii(c) 返回ascii码值 2 chr(c) 返回ascii码值对应的字符 3 || 拼接字符串 4 concat(c1,c2) 拼接字符串 5 distinct 去重 6 initcap(c1) 首字母大写 7 lower(c1) 全部转为小写 8 upper(c1) 全部转为大写 9 instr(c1,c2,[ i [ j ]]) 返回搜索字符串的指定位置 10 length(c1) 返回字符串的长度 11 lpad(c1,n[,c2]) 在字符串的左边填充字符串 12 rpad(c1,n[,c2]) 在字符串的右边填充字符串 13 ltrim(c1[,c2]) 删除左边字符串 14 rtrim(c1[,c2]) 删除右边字符串 15 trim(c1 from c2) 删除左边和右边出现的字符串 16 substr(c1,n1[,n2]) 截取字符串 17 replace(c1,c2,c3) 替换函数 18 translate(c1,c2,c3) 替换字符串 19 nvl(c1,c2) 若第一个参数为空,则返回第二个参数 20 nvl2(c1,c2,c3) 若第一个参数为空,则返回第三个参数,否则返回参数2 21 decode(c1,k1,v1,k2,v2,…,v3) c1等于k1返回v1,以此类推,否则返回v3 日期函数 序号 日期函数 描述 1 sysdate 返回当前系统日期 2 add_months(d1,n1) 返回在原有日期上加n个月后的日期 3 last_day(d1) 返回d1所在月份最后一天的日期 4 months_between(d1,d2) 返回日期d1到日期d2之间的月数 5 round(d1[,c1]) 返回d1按c1四舍五入后期间的第一天日期 6 trunc(d1[,c1]) 返回d1在c1期间的第一天日期 7 next_day(d1[,c1]) 从特定日期得到未来第一个星期几的日期 8 extract(c1 from d1) 提取时间日期中的数据 9 dbtimezone 返回数据库时区 10 sessiontimezone 返回当前会话时区 11 interval c1 set1 变动日期时间数值 转换函数 序号 转换函数 描述 1 to_date 将字符串转化为时间 2 to_char 将时间或者数字转化为字符串 3 to_number 将字符串转化为数字 2数值型函数1abs(x)绝对值12345SQL&gt; select abs(100),abs(-100) from dual; ABS(100) ABS(-100)---------- ---------- 100 100 2sign(x)正负值12345SQL&gt; select sign(100),sign(-100),sign(0) from dual; SIGN(100) SIGN(-100) SIGN(0)---------- ---------- ---------- 1 -1 0 3ceil(x)返回大于等于x的最小整数值123456SQL&gt; select ceil(3.6),ceil(2.8+1.3),ceil(0),ceil(-3.6) 2 from dual; CEIL(3.6) CEIL(2.8+1.3) CEIL(0) CEIL(-3.6)---------- ------------- ---------- ---------- 4 5 0 -3 4floor(x)返回小于等于x的最大整数值123456SQL&gt; select floor(3.6),floor(2.8+1.3),floor(0),floor(-3.6) 2 from dual;FLOOR(3.6) FLOOR(2.8+1.3) FLOOR(0) FLOOR(-3.6)---------- -------------- ---------- ----------- 3 4 0 -4 5power(x,y)返回x的y次幂123456SQL&gt; select power(2.5,2),power(2.5,-2),power(2.5,0),power(10,2) 2 from dual;POWER(2.5,2) POWER(2.5,-2) POWER(2.5,0) POWER(10,2)------------ ------------- ------------ ----------- 6.25 .16 1 100 6log(x,y)返回以x为底的y的对数,即log(底,数值)123456SQL&gt; select log(2.5,6.25),log(2.5,0.16),log(2.5,1),log(10,100) 2 from dual;LOG(2.5,6.25) LOG(2.5,0.16) LOG(2.5,1) LOG(10,100)------------- ------------- ---------- ----------- 2 -2 0 2 7mod(x,y)取余12345SQL&gt; select mod(18,5),mod(25,4) from dual; MOD(18,5) MOD(25,4)---------- ---------- 3 1 8round(x[y])返回按精度y四舍五入后的值123456789SQL&gt; select round(5555.6666,2.6), 2 round(5555.6666,-2.6), 3 round(5555.6666,3), 4 round(5555.6666) 5 from dual;ROUND(5555.6666,2.6) ROUND(5555.6666,-2.6) ROUND(5555.6666,3) ROUND(5555.6666)------------- ----------- ------------- --------- 5555.67 5600 5555.667 5556 9trunc(x[y])返回按精度y截取后的值123456789SQL&gt; select trunc(5555.6666,2.6), 2 trunc(5555.6666,-2.6), 3 trunc(5555.6666,3), 4 trunc(5555.6666) 5 from dual;TRUNC(5555.6666,2.6) TRUNC(5555.6666,-2.6) TRUNC(5555.6666,3) TRUNC(5555.6666)-------------------- --------------------- ------------------ ---------------- 5555.66 5500 5555.666 5555 10sqrt(x)返回x的平方根123456SQL&gt; select sqrt(10),sqrt(25),sqrt(9) 2 from dual; SQRT(10) SQRT(25) SQRT(9)---------- ---------- ----------3.16227766 5 3 2字符型函数1ascii(c)返回ascii码值123456SQL&gt; select ascii(&apos;A&apos;),ascii(&apos;a&apos;),ascii(&apos;1&apos;) 2 from dual;ASCII(&apos;A&apos;) ASCII(&apos;A&apos;) ASCII(&apos;1&apos;)---------- ---------- ---------- 65 97 49 2chr(c)返回ascii码值对应的字符123456SQL&gt; select chr(65),chr(97),chr(49) 2 from dual;CH CH CH-- -- --A a 1 3||拼接字符串123456789SQL&gt; select empno||ename 2 from emp;EMPNO||ENAME---------------7777S_HH%GGH7369SMITH7499ALLEN7521WARD 4concet(c1,c2)拼接字符串123456789SQL&gt; select concat(empno,ename) from emp;CONCAT(EMPNO,ENAME)--------------------------------------------------------------------------------7777S_HH%GGH7369SMITH7499ALLEN7521WARD7566JONES 5distinct去重1234567SQL&gt; select distinct deptno from emp; DEPTNO---------- 30 20 10 6initcap(c1)首字母大写123456789SQL&gt; select initcap(ename) from emp;INITCAP(ENAME)--------------------S_Hh%GghSmithAllenWardJones 7lower(c1)全部转为小写123456789SQL&gt; select lower(ename) from emp;LOWER(ENAME)--------------------s_hh%gghsmithallenwardjones 8upper(c1)全部转为大写123456789SQL&gt; select upper(ename) from emp;UPPER(ENAME)--------------------S_HH%GGHSMITHALLENWARDJONES 9instr(c1,c2,[ i [ j ]])返回搜索字符串的指定位置 I , 搜索的开始位置,默认为1 J , 第J次出现的位置,默认为1 12345SQL&gt; select instr(&apos;oracle rraning&apos;,&apos;ra&apos;) instr from dual; INSTR---------- 2 12345SQL&gt; select instr(&apos;oracle rraning&apos;,&apos;ra&apos;,1,2) instr from dual; INSTR---------- 9 10length(c1)返回字符串的长度12345678910SQL&gt; select ename,length(ename) 2 from emp;ENAME LENGTH(ENAME)-------------------- -------------S_HH%GGH 8SMITH 5ALLEN 5WARD 4JONES 5 11lpad(c1,n[,c2])在字符串的左边填充字符串 c1 字符串 n 追加后字符总长度 c2 追加字符串,默认为空格 —– 如果c1长度大于n,则返回c1左边n个字符 如果c1长度小于n,且c2和c1连接后大于n,则返回连接后边n个字符123456789101112SQL&gt; select lpad(ename,10,&apos;*?&apos;) one, 2 lpad(ename,5,&apos;*?&apos;) two, 3 lpad(ename,10,&apos;!@#$%^&amp;*()_+&apos;) three 4 from emp; ONE TWO THREE*?S_HH%GGH S_HH% !@S_HH%GGH*?*?*SMITH SMITH !@#$%SMITH*?*?*ALLEN ALLEN !@#$%ALLEN*?*?*?WARD *WARD !@#$%^WARD*?*?*JONES JONES !@#$%JONES 12rpad(c1,n[,c2])在字符串的右边填充字符串 如果c1长度大于n,则返回c2左边n个字符 如果c1长度小于n,c1和c2连接后大于n ,则返回连接后的左边n个字符 如果c1长度小于n,c1和c2连接后大于n,则返回c1与多个重复的c2连接(总长度&gt;=n)后的左边n个字符 在字符串’gao’的左边和右边分别加7个6 123456SQL&gt; select lpad(rpad(&apos;gao&apos;,10,&apos;6666666&apos;),17,&apos;6666666&apos;) text 2 from dual;TEXT----------------------------------6666666gao6666666 123456SQL&gt; select rpad(lpad(&apos;gao&apos;,10,&apos;6666666&apos;),17,&apos;6666666&apos;) text 2 from dual;TEXT----------------------------------6666666gao6666666 13ltrim(c1[,c2])删除左边字符串1234567SQL&gt; select ltrim(&apos; qing dao shi&apos;), 2 length(ltrim(&apos; qing dao shi&apos;)), 3 ltrim(&apos;qing dao shi&apos;,&apos;qing dao &apos;), 4 length(ltrim(&apos;qing dao shi&apos;,&apos;qing dao &apos;)) 5 from dual; ------ -------------------------------------qing dao shi 12 shi 3 14rtrim(c1[,c2])删除右边字符串1234567SQL&gt; select rtrim(&apos;qing dao shi &apos;), 2 length(rtrim(&apos;qing dao shi &apos;)) 3 from dual;RTRIM(&apos;QINGDAOSHI&apos;) LENGTH(RTRIM(&apos;QINGDAOSHI&apos;))------------------------ ---------------------------qing dao shi 12 15trim(c1 from c2)删除左边和右边出现的字符串1234567SQL&gt; select trim(&apos; qing dao shi &apos;), 2 length(trim(&apos; qing dao shi &apos;)) 3 from dual;TRIM(&apos;QINGDAOSHI&apos;) LENGTH(TRIM(&apos;QINGDAOSHI&apos;))------------------------ --------------------------qing dao shi 12 16substr(c1,n1[,n2])截取字符串在字符表达式c1里,从n1开始截取n2个字符;若不指定n2则截取从第y个字符指导结束的字符 1234567SQL&gt; select substr(&apos;20191029&apos;,1,4), 2 substr(&apos;20191029&apos;,5) 3 from dual;SUBSTR(&apos; SUBSTR(&apos;-------- --------2019 1029 17replace(c1,c2,c3)替换函数1234567SQL&gt; select replace(&apos;i love you&apos;,&apos;i&apos;,&apos;he&apos;), 2 replace(&apos;i love you&apos;,&apos;i &apos;) 3 from dual;REPLACE(&apos;ILOVEYOU&apos;,&apos;I&apos; REPLACE(&apos;ILOVEYO---------------------- ----------------he love you love you 18translate(c1,c2,c3)替换字符串 如果c3长度大于c2,则c3后面长处的字符无效 如果c3长度小于c2,则c2后面长处的字符均替换为空(删除) 如果c3长度为0,则返回空字符串 如果c2里字符重复,按首次位置为替换依据1234567SQL&gt; select translate(&apos;he love you&apos;,&apos;he&apos;,&apos;i&apos;), 2 translate(&apos;he love you&apos;,&apos;o&apos;,&apos;i&apos;) 3 from dual;TRANSLATE(&apos;HELOVEY TRANSLATE(&apos;HELOVEYOU&apos;,------------------ ----------------------i lov you he live yiu 19nvl(c1,c2)若第一个参数为空,则返回第二个参数 2个参数,若第一个参数为空,则返回第二个参数 123456789SQL&gt; select empno, 2 comm, 3 nvl(a.comm,1) 4 from emp a where a.empno in(7499,7369); EMPNO COMM NVL(A.COMM,1)---------- ---------- ------------- 7369 1 7499 300 300 20nvl2(c1,c2,c3)若第一个参数为空,则返回第三个参数,否则返回参数2 3个参数,若第一个参数为空,则返回参数3,否则返回参数2 123456789SQL&gt; select empno, 2 comm, 3 nvl2(a.comm,1,0) 4 from emp a where a.empno in(7499,7369); EMPNO COMM NVL2(A.COMM,1,0)---------- ---------- ---------------- 7369 0 7499 300 1 21decode(c1,k1,v1,k2,v2,…,v3)c1等于k1返回v1,以此类推,否则返回v3 多个参数,成对出现.若参数1的值等于参数2，则返回参数3,若参数1的值等于参数4,则返回参数5,以此类推 123456789101112131415SQL&gt; select sal, decode(a.sal, 800, 1, 950, 2, 1100, 3, 1250, 4, 1300, 5, 6) 2 from emp a 3 where a.sal &gt; 0 4 order by a.sal asc; SAL DECODE(A.SAL,800,1,950,2,1100,3,1250,4,1300,5,6)---------- ------------------------------------------------ 800 1 950 2 1100 3 1250 4 1250 4 1300 5 1500 6 1600 6 日期函数1sysdate返回当前系统日期123456SQL&gt; select sysdate time 2 from dual;TIME--------------11-11月-19 2add_months(d1,n1)返回在原有日期上加n个月后的日期12345678SQL&gt; select sysdate, 2 add_months(sysdate,2), 3 add_months(sysdate,-2) 4 from dual;SYSDATE ADD_MONTHS(SYS ADD_MONTHS(SYS-------------- -------------- --------------11-11月-19 11-1月 -20 11-9月 -19 3last_day(d1)返回d1所在月份最后一天的日期1234567SQL&gt; select sysdate, 2 last_day(sysdate) 3 from dual;SYSDATE LAST_DAY(SYSDA-------------- --------------11-11月-19 30-11月-19 4months_between(d1,d2)返回日期d1到日期d2之间的月数12345678SQL&gt; select sysdate, 2 months_between(sysdate,to_date(&apos;2019-01-01&apos;,&apos;YYYY-MM-DD&apos;)) d2, 3 months_between(sysdate,to_date(&apos;2020-01-01&apos;,&apos;YYYY-MM-DD&apos;)) d3 4 from dual;SYSDATE D2 D3-------------- ---------- ----------11-11月-19 10.349319 -1.650681 5round(d1[,c1])返回d1按c1四舍五入后期间的第一天日期c1对应的参数表 最近0点日期 参数c1或j最近的星期日 day或者dy或者d最近月初日期 month或者mon或者mm或者rm最近季日期 q最近年初日期 syear或者year或者yyyy或者yyy或者yy或者y(多个y表示精度)最近世纪初日期 cc或者scc 12345678910SQL&gt; select sysdate 当前日期, 2 round(sysdate,&apos;syear&apos;) 最近年初日期, 3 round(sysdate,&apos;q&apos;) 最近季度日期, 4 round(sysdate,&apos;month&apos;) 最近月初, 5 round(sysdate) 最近0点 6 from dual;当前日期 最近年初日期 最近季度日期 最近月初 最近0点-------------- -------------- -------------- -------------- --------------11-11月-19 01-1月 -20 01-10月-19 01-11月-19 12-11月-19 6trunc(d1[,c1])返回d1在c1期间的第一天日期1234567891011SQL&gt; select sysdate 当前日期, 2 trunc(sysdate) 今天日期, 3 trunc(sysdate,&apos;day&apos;) 本周日, 4 trunc(sysdate,&apos;month&apos;) 本月初, 5 trunc(sysdate,&apos;q&apos;) 本季初, 6 trunc(sysdate,&apos;year&apos;) 本年初日期 7 from dual;当前日期 今天日期 本周日 本月初 本季初 本年初日期-------------- -------------- -------------- -------------- -------------- --------------11-11月-19 11-11月-19 10-11月-19 01-11月-19 01-10月-19 01-1月 -19 7next_day(d1[,c1])从特定日期得到未来第一个星期几的日期12345678910111213141516SQL&gt; select sysdate 当前日期, 2 next_day(sysdate,&apos;星期一&apos;) 未来第一个星期一, 3 next_day(sysdate,&apos;星期二&apos;) 未来第一个星期二, 4 next_day(sysdate,&apos;星期三&apos;) 未来第一个星期三, 5 next_day(sysdate,&apos;星期四&apos;) 未来第一个星期四, 6 next_day(sysdate,&apos;星期五&apos;) 未来第一个星期五, 7 next_day(sysdate,&apos;星期六&apos;) 未来第一个星期六, 8 next_day(sysdate,&apos;星期日&apos;) 未来第一个星期日 9 from dual;当前日期 未来第一个星期 未来第一个星期 未来第一个星期 -------------- -------------- -------------- -------------- 11-11月-19 18-11月-19 12-11月-19 13-11月-19 未来第一个星期 未来第一个星期 未来第一个星期 未来第一个星期 -------------- -------------- -------------- -------------- 14-11月-19 15-11月-19 16-11月-19 17-11月-19 8extract(c1 from d1)提取时间日期中的数据123456789101112SQL&gt; select 2 extract(hour from timestamp &apos;2001-2-16 2:38:40 &apos; ) 小时, 3 extract(minute from timestamp &apos;2001-2-16 2:38:40 &apos; ) 分钟, 4 extract(second from timestamp &apos;2001-2-16 2:38:40 &apos; ) 秒, 5 extract(DAY from timestamp &apos;2001-2-16 2:38:40 &apos; ) 日, 6 extract(MONTH from timestamp &apos;2001-2-16 2:38:40 &apos; ) 月, 7 extract(YEAR from timestamp &apos;2001-2-16 2:38:40 &apos; ) 年 8 from dual; 小时 分钟 秒 日 月 年---------- ---------- ---------- ---------- ---------- ---------- 2 38 40 16 2 2001 123456789SQL&gt; select sysdate 当前日期, 2 extract(DAY from sysdate ) 日, 3 extract(MONTH from sysdate ) 月, 4 extract(YEAR from sysdate ) 年 5 from dual;当前日期 日 月 年-------------- ---------- ---------- ----------11-11月-19 11 11 2019 9dbtimezone返回数据库时区123456SQL&gt; select dbtimezone 2 from dual;DBTIMEZONE------------+00:00 10sessiontimezone返回当前会话时区1234567SQL&gt; select dbtimezone, 2 sessiontimezone 3 from dual;DBTIMEZONE SESSIONTIMEZONE------------ ------------+00:00 +08:00 11interval c1 set1变动日期时间数值123456789101112131415161718SQL&gt; select trunc(sysdate)+(interval &apos;1&apos; second) 加1秒, 2 trunc(sysdate)+(interval &apos;1&apos; minute) 加1分钟, 3 trunc(sysdate)+(interval &apos;1&apos; hour) 加1小时, 4 trunc(sysdate)+(INTERVAL &apos;1&apos; DAY) 加1天, 5 trunc(sysdate)+(INTERVAL &apos;1&apos; MONTH) 加1月, 6 trunc(sysdate)+(INTERVAL &apos;1&apos; YEAR) 加1年, 7 trunc(sysdate)+(interval &apos;01:02:03&apos; hour to second) 加指定小时到秒, 8 trunc(sysdate)+(interval &apos;01:02&apos; minute to second) 加指定分钟到秒, 9 trunc(sysdate)+(interval &apos;01:02&apos; hour to minute) 加指定小时到分钟, 10 trunc(sysdate)+(interval &apos;2 01:02&apos; day to minute) 加指定天数到分钟 11 from dual;加1秒 加1分钟 加1小时 加1天 加1月 加1年 11-11月-19 11-11月-19 11-11月-19 12-11月-19 11-12月-19 11-11月-20 加指定小时到秒 加指定分钟到秒 加指定小时到分 加指定天数到分 11-11月-19 11-11月-19 11-11月-19 13-11月-19 转换函数to_date将字符串转化为时间12345SQL&gt; select to_date(&apos;20191110&apos;,&apos;YYYYMMDD&apos;) from dual;TO_DATE(&apos;20191--------------10-11月-19 to_char将时间或者数字转化为字符串12345SQL&gt; select to_char(sysdate,&apos;YYYYMMDD&apos;) from dual;TO_CHAR(SYSDATE,----------------20191111 to_number将字符串转化为数字12345SQL&gt; select to_number(&apos;123&apos;) from dual;TO_NUMBER(&apos;123&apos;)---------------- 123]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle学习1]]></title>
    <url>%2F2019%2F11%2F10%2Foracle%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[1数据库介绍数据库分类 关系型数据库:oracle, mysql, db2, sql server, sqllite等 非关系型数据库:redis, hbase等了解 DBMS: database management system数据库管理系统 RDBMS: relational database management system关系型数据库管理系统 2sqlplus简单使用登录 1234567891011121314C:\Users\inmeditation&gt;sqlplusSQL*Plus: Release 11.2.0.1.0 Production on 星期日 11月 10 19:00:28 2019Copyright (c) 1982, 2010, Oracle. All rights reserved.请输入用户名: scott输入口令:连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; 查看当前登录用户 12SQL&gt; show user;USER 为 &quot;SCOTT&quot; 查看,设置搜索后结果行的长度 12345SQL&gt; show linesizelinesize 80SQL&gt; set linesize 500;SQL&gt; show linesize;linesize 500 查看,设置搜索后结页面的长度 12345SQL&gt; show pagesize;pagesize 14SQL&gt; set pagesize 100;SQL&gt; show pagesize;pagesize 100 注意,行长和页长再次登录会恢复默认值 查看表结构 1234567891011SQL&gt; desc emp; 名称 是否为空? 类型 ------ -------- -------------------------- EMPNO NOT NULL NUMBER(4) ENAME VARCHAR2(10) JOB VARCHAR2(9) MGR NUMBER(4) HIREDATE DATE SAL NUMBER(7,2) COMM NUMBER(7,2) DEPTNO NUMBER(2) 更改当前用户的密码 12SQL&gt; alter user scott identified by scottpw;用户已更改。 通过交互方式更改当前用户密码 123456SQL&gt; passw更改 SCOTT 的口令旧口令:新口令:重新键入新口令:口令已更改 切换到超级用户 12345SQL&gt; conn sys as sysdba输入口令:已连接。SQL&gt; conn system/sys已连接。 超级用户下解锁scott用户 12SQL&gt; alter user scott account unlock;用户已更改。 超级用户下更改scott账户的密码 12SQL&gt; alter user scott identified by scott;用户已更改。 退出当前数据库账号 1234SQL&gt; disc从 Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 断开SQL&gt; 退出数据库 12SQL&gt; exitC:\Users\inmeditation&gt; 1234SQL&gt; quit从 Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 断开C:\Users\inmeditation&gt; 3简单查询1 表的概念: Excel中的表格就是表。竖着叫一列.横着是一行 表中也是一样,其中每列叫做列或者字段,每行叫做记录 查询表中所有信息123456789SQL&gt; select * from emp; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- -------------- ---------- ---------- ---------- 7777 S_HH%GGH CLERK 7902 20 7369 SMITH CLERK 7902 17-12月-80 800 20 7499 ALLEN SALESMAN 7698 20-2月 -81 1600 300 30 7521 WARD SALESMAN 7698 22-2月 -81 1250 500 30 7566 JONES MANAGER 7839 02-4月 -81 2975 20 查询单个列信息:姓名,入职时间,部门123456789SQL&gt; select ename,hiredate,deptno from emp;ENAME HIREDATE DEPTNO-------------------- -------------- ----------S_HH%GGH 20SMITH 17-12月-80 20ALLEN 20-2月 -81 30WARD 22-2月 -81 30JONES 02-4月 -81 20 2 特殊的列:rowid和rownumrowid 数据库中唯一的一个无规律字符串, rowid能唯一的确定一条数据. 每条数据都有一个rowid,唯一且不为空. rownum:伪列,用于过滤数据可以写作rownum&lt;5, rownum&lt;=6,rownum=1但用rownum=2或者rownum&gt;3,这种写法是不能运行的则这个数字必须是小于等于1的整数,否则无法查出数据. 1234567891011SQL&gt; select ename,rowid,rownum from emp;ENAME ROWID ROWNUM-------------------- ------------------ ----------S_HH%GGH AAAR3sAAEAAAACWAAA 1SMITH AAAR3sAAEAAAACXAAA 2ALLEN AAAR3sAAEAAAACXAAB 3WARD AAAR3sAAEAAAACXAAC 4JONES AAAR3sAAEAAAACXAAD 5MARTIN AAAR3sAAEAAAACXAAE 6BLAKE AAAR3sAAEAAAACXAAF 7 3 别名表别名 就是给表另取一个名字,这个名字可以代替表名 123456789101112SQL&gt; select p.empno,p.ename from emp p; EMPNO ENAME---------- -------------------- 7777 S_HH%GGH 7369 SMITH 7499 ALLEN 7521 WARD 7566 JONES 7654 MARTIN 7698 BLAKE 7782 CLARK 列别名 关键字:as,可以省略 12345678910SQL&gt; select p.empno as 员工编号,p.ename 员工姓名 from emp p; 员工编号 员工姓名---------- -------------------- 7777 S_HH%GGH 7369 SMITH 7499 ALLEN 7521 WARD 7566 JONES 7654 MARTIN 条件查询where1 not 取反 查看工资大于2000的员工姓名 1234567891011SQL&gt; select ename,sal from emp 2 where not sal&lt;2000;ENAME SAL-------------------- ----------JONES 2975BLAKE 2850CLARK 2450SCOTT 3000KING 5000FORD 3000 2 like 模糊查询 | 模糊匹配字符串 占位符 % 表示零个或者若干个任意字符 _ 表示一个任意字符 查询名字不是以S开头的所有员工姓名 123456789SQL&gt; select ename from emp 2 where ename not like &apos;S%&apos;;ENAME--------------------ALLENWARDJONESMARTIN 查询名字以S开头的所有员工姓名,且名字长度为5 1234567SQL&gt; select ename from emp 2 where ename like &apos;S____&apos;;ENAME--------------------SMITHSCOTT 占位符在使用时,应该尽量避免在字符串的前面和后面都使用% escape定义转义字符查询名字中带有_的员工信息 123456SQL&gt; select ename from emp 2 where ename like &apos;%\_%&apos;escape &apos;\&apos;;ENAME--------------------S_HH%GGH 查找emp表中ename列同时有%和_，且不挨在一起的数据; 1234567SQL&gt; select ename from emp 2 where ename like &apos;%/%%_/_%&apos; escape &apos;/&apos; 3 or ename like &apos;%/_%_/%%&apos; escape &apos;/&apos;;ENAME--------------------S_HH%GGH 3 is null 查询字段值是空值的数据 查看有佣金的员工姓名 123456789SQL&gt; select ename from emp 2 where comm is not null;ENAME--------------------ALLENWARDMARTINTURNER 4 in 后面跟一个集合或者子查询,用来查询条件列值是否在后面集合中 查询10号和20号部门之外的员工姓名和部门 123456789SQL&gt; select ename,deptno from emp 2 where deptno not in(10,20);ENAME DEPTNO-------------------- ----------ALLEN 30WARD 30MARTIN 30BLAKE 30 order by1排序 asc:表示升序,默认排序方式,从小到大 desc:表示降序 123456789101112SQL&gt; select ename,sal from emp 2 order by sal desc;ENAME SAL-------------------- ----------S_HH%GGHKING 5000FORD 3000SCOTT 3000JONES 2975BLAKE 2850CLARK 2450 多列排序 如果出现两个或者两个以上的列 排序时,先按第一个列进行排序如果第一列的值相等,那么安照下一个排序列进行排序 查询员工信息,按照部门编号升序排序,如果部门相同按照工资降序排序 12345678910111213SQL&gt; select ename,sal,deptno from emp 2 order by deptno,sal desc;ENAME SAL DEPTNO-------------------- ---------- ----------KING 5000 10CLARK 2450 10MILLER 1300 10S_HH%GGH 20FORD 3000 20SCOTT 3000 20JONES 2975 20ADAMS 1100 20 也可以写为 12345678910111213SQL&gt; select ename,sal,deptno from emp 2 order by 3,2 desc;ENAME SAL DEPTNO-------------------- ---------- ----------KING 5000 10CLARK 2450 10MILLER 1300 10S_HH%GGH 20FORD 3000 20SCOTT 3000 20JONES 2975 20ADAMS 1100 20 group by 按照某一列数据进行分组 语法: select 列名 from 表名 group by 列名; select后可以跟的内容 是 group by的列,即分组列; 经过聚合函数处理过的数据. SUM()–求和 MIN()–取最小值 MAX()–取最大值 AVG()–平均值 COUNT()–求数量 按照不同的组号来分组,并统计每组人数,最高工资和最低工资等信息 123456789SQL&gt; select deptno,count(*),sum(sal),avg(sal),max(sal),min(sal) 2 from emp 3 group by deptno; DEPTNO COUNT(*) SUM(SAL) AVG(SAL) MAX(SAL) MIN(SAL)---------- ---------- ---------- ---------- ---------- ---------- 30 6 9400 1566.66667 2850 950 20 6 10875 2175 3000 800 10 3 8750 2916.66667 5000 1300 多列分组 多列分组时,多个分组列的值同时相等时,才属于同一个组 123456789101112131415SQL&gt; select deptno,job,count(*),max(sal) 2 from emp 3 group by deptno,job; DEPTNO JOB COUNT(*) MAX(SAL)---------- ------------------ ---------- ---------- 20 CLERK 3 1100 30 SALESMAN 4 1600 20 MANAGER 1 2975 30 CLERK 1 950 10 PRESIDENT 1 5000 30 MANAGER 1 2850 10 CLERK 1 1300 10 MANAGER 1 2450 20 ANALYST 2 3000 having 对分组后的数据进行筛选 查询各个部门的部门人数,和平均工资,要求部门的平均工资大于2000 123456789SQL&gt; select deptno,count(*),avg(sal) 2 from emp 3 group by deptno 4 having avg(sal)&gt;2000; DEPTNO COUNT(*) AVG(SAL)---------- ---------- ---------- 20 6 2175 10 3 2916.66667 having和where的区别 having 后面跟条件表达式 having是对分组后的数据进行筛选 后面可以跟聚合函数,它比where后执行 where 条件表达式,它后面可以跟普通函数,不能使用聚合函数,它是分组前对数据的筛选,优先执行 补充执行顺序: where group by having select order by case when:根据分支的不同返回不同的值 两种写法12345671. select deptno,case deptno when 10 then &apos;部门1&apos; when 20 then &apos;部门2&apos; when 30 then &apos;部门3&apos; else &apos;其他部门&apos; endfrom emp; 1234562.select deptno, case when deptno=30 then &apos;部门3&apos; when deptno=20 then &apos;部门2&apos; when deptno=10 then &apos;部门1&apos; else &apos;其他部门&apos; end from emp; 查询emp表,将职位为ANALYST,CLERK和SALESMAN的显示为工人,MANAGER和PRESIDENT显示为管理员;12345678910111213141516SQL&gt; select ename,case 2 when job in(&apos;ANALYST&apos;,&apos;CLERK&apos;,&apos;SALESMAN&apos;) then &apos;工人&apos; 3 when job in(&apos;MANAGER&apos;,&apos;PRESIDENT&apos;) then &apos;管理员&apos; 4 else &apos;其他人&apos; end 5 from emp;ENAME CASEWHENJOBIN(&apos;ANA-------------------- ------------------S_HH%GGH 工人SMITH 工人ALLEN 工人WARD 工人JONES 管理员MARTIN 工人BLAKE 管理员CLARK 管理员 另一种写法 12345678910111213141516SQL&gt; select ename ,case 2 when job=&apos;ANALYST&apos; or job=&apos;CLERK&apos; or job=&apos;SALESMAN&apos; then &apos;工人&apos; 3 when job=&apos;MANAGER&apos; or job=&apos;PRESIDENT&apos; then &apos;管理员&apos; 4 else &apos;其他人&apos; end 5 from emp;ENAME CASEWHENJOB=&apos;ANALY-------------------- ------------------S_HH%GGH 工人SMITH 工人ALLEN 工人WARD 工人JONES 管理员MARTIN 工人BLAKE 管理员CLARK 管理员 查询emp表,查询出sal&lt;1000, sal在1000-3000,和sal大于3000的人数;12345678910111213141516SQL&gt; select case 2 when sal&lt;1000 then &apos;小于1000&apos; 3 when sal&gt;=1000 and sal&lt;=3000 then &apos;1000-3000&apos; 4 else &apos;大于3000&apos; end as &quot;范围&quot;, count(1) 数量 5 from emp 6 where sal&gt;=0 7 group by case 8 when sal&lt;1000 then &apos;小于1000&apos; 9 when sal&gt;=1000 and sal&lt;=3000 then &apos;1000-3000&apos; 10 else &apos;大于3000&apos; end;范围 数量-------------------- ----------小于1000 21000-3000 11大于3000 1 另一种写法 12345678SQL&gt; select sum(case when sal&lt;1000 then 1 else 0 end) &quot;工资小于1000&quot;, 2 sum(case when sal&gt;=1000 and sal&lt;=3000 then 1 else 0 end) &quot;工资在1000-3000&quot;, 3 sum(case when sal&gt;3000 then 1 else 0 end) &quot;工资大于3000&quot; 4 from emp;工资小于1000 工资在1000-3000 工资大于3000------------ --------------- ------------ 2 11 1]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle简单查询单词]]></title>
    <url>%2F2019%2F11%2F07%2Foracle%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[单词 释义 select 查询 from 从… where 条件查询 as 别名 not 取反 and 和 or 或者 between…and… 范围取值,包含边界 like 模糊查询 escape 定义 转义字符 order by 排序 asc 正序 desc 倒序 group by 分组 sum 求和 max 最大值 min 最小值 avg 平均值 count 数量 having 条件查询 case when…then else…end 取值时,更改数据的值]]></content>
      <categories>
        <category>单词记忆</category>
      </categories>
      <tags>
        <tag>oracle单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql单表查询]]></title>
    <url>%2F2019%2F09%2F04%2Fmysql%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[准备工作 准备表company.employee5 1234567891011121314151617mysql&gt; create database company;Query OK, 1 row affected (0.00 sec)mysql&gt; use company;Database changedmysql&gt; create table company.employee5( -&gt; id int primary key auto_increment not null, -&gt; name varchar(30) not null, -&gt; sex enum(&apos;male&apos;,&apos;female&apos;) default &apos;male&apos; not null, -&gt; hire_date date not null, -&gt; post varchar(50) not null, -&gt; job_description varchar(100), -&gt; salary double(15,2) not null, -&gt; office int, -&gt; dep_id int -&gt; );Query OK, 0 rows affected (0.24 sec) 插入数据 12345678910111213mysql&gt; insert into company.employee5(name,sex,hire_date,post,job_description,salary,office,dep_id) value -&gt; (&apos;jack&apos;,&apos;male&apos;,&apos;20180202&apos;,&apos;instructor&apos;,&apos;teach&apos;,5000,501,100), -&gt; (&apos;tom&apos;,&apos;male&apos;,&apos;20180203&apos;,&apos;instructor&apos;,&apos;teach&apos;,5000,501,100), -&gt; (&apos;robin&apos;,&apos;male&apos;,&apos;20180202&apos;,&apos;instructor&apos;,&apos;teach&apos;,8000,501,100), -&gt; (&apos;alice&apos;,&apos;female&apos;,&apos;20180202&apos;,&apos;instructor&apos;,&apos;teach&apos;,7200,501,100), -&gt; (&apos;tianyun&apos;,&apos;male&apos;,&apos;20180202&apos;,&apos;instructor&apos;,&apos;teach&apos;,600,502,100), -&gt; (&apos;harry&apos;,&apos;male&apos;,&apos;20180202&apos;,&apos;hr&apos;,NULL,6000,502,101), -&gt; (&apos;emma&apos;,&apos;female&apos;,&apos;20180206&apos;,&apos;sale&apos;,&apos;salecc&apos;,20000,503,102), -&gt; (&apos;christine&apos;,&apos;female&apos;,&apos;20180205&apos;,&apos;sale&apos;,NULL,2200,503,102), -&gt; (&apos;zhuzhu&apos;,&apos;male&apos;,&apos;20180205&apos;,&apos;sale&apos;,NULL,2200,503,102), -&gt; (&apos;gougou&apos;,&apos;male&apos;,&apos;20180205&apos;,&apos;sale&apos;,&apos;&apos;,2200,503,102);Query OK, 10 rows affected (0.01 sec)Records: 10 Duplicates: 0 Warnings: 0 简单查询查询表全部内容 12345678910111213141516mysql&gt; select * from employee5; +----+-----------+--------+------------+------------+-----------------+----------+--------+--------+| id | name | sex | hire_date | post | job_description | salary | office | dep_id |+----+-----------+--------+------------+------------+-----------------+----------+--------+--------+| 2 | jack | male | 2018-02-02 | instructor | teach | 5000.00 | 501 | 100 || 3 | tom | male | 2018-02-03 | instructor | teach | 5000.00 | 501 | 100 || 4 | robin | male | 2018-02-02 | instructor | teach | 8000.00 | 501 | 100 || 5 | alice | female | 2018-02-02 | instructor | teach | 7200.00 | 501 | 100 || 6 | tianyun | male | 2018-02-02 | instructor | teach | 600.00 | 502 | 100 || 7 | harry | male | 2018-02-02 | hr | NULL | 6000.00 | 502 | 101 || 8 | emma | female | 2018-02-06 | sale | salecc | 20000.00 | 503 | 102 || 9 | christine | female | 2018-02-05 | sale | NULL | 2200.00 | 503 | 102 || 10 | zhuzhu | male | 2018-02-05 | sale | NULL | 2200.00 | 503 | 102 || 11 | gougou | male | 2018-02-05 | sale | | 2200.00 | 503 | 102 |+----+-----------+--------+------------+------------+-----------------+----------+--------+--------+10 rows in set (0.00 sec) 查询表的某几个字段 12345678910111213141516mysql&gt; select name,post,salary from employee5;+-----------+------------+----------+| name | post | salary |+-----------+------------+----------+| jack | instructor | 5000.00 || tom | instructor | 5000.00 || robin | instructor | 8000.00 || alice | instructor | 7200.00 || tianyun | instructor | 600.00 || harry | hr | 6000.00 || emma | sale | 20000.00 || christine | sale | 2200.00 || zhuzhu | sale | 2200.00 || gougou | sale | 2200.00 |+-----------+------------+----------+10 rows in set (0.00 sec) 去重,仅用于单一字段 123456789mysql&gt; select distinct post from employee5;+------------+| post |+------------+| instructor || hr || sale |+------------+3 rows in set (0.00 sec) 计算出每个员工的年薪(14薪) 12345678910111213141516mysql&gt; select name,salary,salary*14 from employee5;+-----------+----------+-----------+| name | salary | salary*14 |+-----------+----------+-----------+| jack | 5000.00 | 70000.00 || tom | 5000.00 | 70000.00 || robin | 8000.00 | 112000.00 || alice | 7200.00 | 100800.00 || tianyun | 600.00 | 8400.00 || harry | 6000.00 | 84000.00 || emma | 20000.00 | 280000.00 || christine | 2200.00 | 30800.00 || zhuzhu | 2200.00 | 30800.00 || gougou | 2200.00 | 30800.00 |+-----------+----------+-----------+10 rows in set (0.00 sec) 显示别名,将salary*14显示为annual_salary 12345678910111213141516mysql&gt; select name,salary,salary*14 as annual_salary from employee5;+-----------+----------+---------------+| name | salary | annual_salary |+-----------+----------+---------------+| jack | 5000.00 | 70000.00 || tom | 5000.00 | 70000.00 || robin | 8000.00 | 112000.00 || alice | 7200.00 | 100800.00 || tianyun | 600.00 | 8400.00 || harry | 6000.00 | 84000.00 || emma | 20000.00 | 280000.00 || christine | 2200.00 | 30800.00 || zhuzhu | 2200.00 | 30800.00 || gougou | 2200.00 | 30800.00 |+-----------+----------+---------------+10 rows in set (0.00 sec) 定义显示格式 CONCAT()函数用来连接字符串 12345678910111213141516mysql&gt; select concat(name,&apos; annual salary: &apos;,salary*14) as Annual_salary from employee5;+------------------------------------+| Annual_salary |+------------------------------------+| jack annual salary: 70000.00 || tom annual salary: 70000.00 || robin annual salary: 112000.00 || alice annual salary: 100800.00 || tianyun annual salary: 8400.00 || harry annual salary: 84000.00 || emma annual salary: 280000.00 || christine annual salary: 30800.00 || zhuzhu annual salary: 30800.00 || gougou annual salary: 30800.00 |+------------------------------------+10 rows in set (0.00 sec) 2条件查询单条件查询查询职位是hr的员工 1234567mysql&gt; select name,post from employee5 where post=&apos;hr&apos;;+-------+------+| name | post |+-------+------+| harry | hr |+-------+------+1 row in set (0.00 sec) 多条件查询查看职位是”sale销售”的员工,但是薪水少于等于5000 123456789mysql&gt; select name,post,salary from employee5 where post=&apos;sale&apos; and salary&lt;=5000;+-----------+------+---------+| name | post | salary |+-----------+------+---------+| christine | sale | 2200.00 || zhuzhu | sale | 2200.00 || gougou | sale | 2200.00 |+-----------+------+---------+3 rows in set (0.00 sec) 关键字between and 和 not between and查看工资5000~10000范围内的员工 1234567891011mysql&gt; select name,salary from employee5 where salary between 5000 and 10000;+-------+---------+| name | salary |+-------+---------+| jack | 5000.00 || tom | 5000.00 || robin | 8000.00 || alice | 7200.00 || harry | 6000.00 |+-------+---------+5 rows in set (0.00 sec) 查看不是这个范围的员工 1234567891011mysql&gt; select name,salary from employee5 where salary not between 5000 and 10000;+-----------+----------+| name | salary |+-----------+----------+| tianyun | 600.00 || emma | 20000.00 || christine | 2200.00 || zhuzhu | 2200.00 || gougou | 2200.00 |+-----------+----------+5 rows in set (0.00 sec) 关键字is null和is not null 空 和 非空 查看job_description职位描述字段为空的员工 123456789mysql&gt; select name,job_description from employee5 where job_description is null;+-----------+-----------------+| name | job_description |+-----------+-----------------+| harry | NULL || christine | NULL || zhuzhu | NULL |+-----------+-----------------+3 rows in set (0.00 sec) 查看job_description职位描述字段不为空的员工 12345678910111213mysql&gt; select name,job_description from employee5 where job_description is not null;+---------+-----------------+| name | job_description |+---------+-----------------+| jack | teach || tom | teach || robin | teach || alice | teach || tianyun | teach || emma | salecc || gougou | |+---------+-----------------+7 rows in set (0.00 sec) 集合查询 in和not in12345678910mysql&gt; select name,salary from employee5 where salary=2000 or salary=5000 or salary=6000 or salary=20000;+-------+----------+| name | salary |+-------+----------+| jack | 5000.00 || tom | 5000.00 || harry | 6000.00 || emma | 20000.00 |+-------+----------+4 rows in set (0.00 sec) 1234567891011121314151617181920212223mysql&gt; select name,salary from employee5 where salary in (2000,5000,6000,20000);+-------+----------+| name | salary |+-------+----------+| jack | 5000.00 || tom | 5000.00 || harry | 6000.00 || emma | 20000.00 |+-------+----------+4 rows in set (0.00 sec)mysql&gt; select name,salary from employee5 where salary not in (2000,5000,6000,20000);+-----------+---------+| name | salary |+-----------+---------+| robin | 8000.00 || alice | 7200.00 || tianyun | 600.00 || christine | 2200.00 || zhuzhu | 2200.00 || gougou | 2200.00 |+-----------+---------+6 rows in set (0.00 sec) 模糊查询 % —- 任意多个字符 _ —- 任意单个字符123456789101112131415161718mysql&gt; select name from employee5 where name like &apos;al%&apos;;+-------+| name |+-------+| alice |+-------+1 row in set (0.00 sec)mysql&gt; select name from employee5 where name like &apos;al_&apos;;Empty set (0.00 sec)mysql&gt; select name from employee5 where name like &apos;al___&apos;;+-------+| name |+-------+| alice |+-------+1 row in set (0.00 sec) 3排序单列排序默认使用asc ,升序从小到大 12345678910111213141516mysql&gt; select name,salary from employee5 order by salary;+-----------+----------+| name | salary |+-----------+----------+| tianyun | 600.00 || christine | 2200.00 || zhuzhu | 2200.00 || gougou | 2200.00 || jack | 5000.00 || tom | 5000.00 || harry | 6000.00 || alice | 7200.00 || robin | 8000.00 || emma | 20000.00 |+-----------+----------+10 rows in set (0.00 sec) 降序从大到小,需要指定为desc 12345678910111213141516mysql&gt; select name,salary from employee5 order by salary desc;+-----------+----------+| name | salary |+-----------+----------+| emma | 20000.00 || robin | 8000.00 || alice | 7200.00 || harry | 6000.00 || jack | 5000.00 || tom | 5000.00 || christine | 2200.00 || zhuzhu | 2200.00 || gougou | 2200.00 || tianyun | 600.00 |+-----------+----------+10 rows in set (0.00 sec) 多列排序先按入职时间降序,再按薪资升序 12345678910111213141516mysql&gt; mysql&gt; select name,hire_date,salary from employee5 order by hire_date desc, salary;+-----------+------------+----------+| name | hire_date | salary |+-----------+------------+----------+| emma | 2018-02-06 | 20000.00 || christine | 2018-02-05 | 2200.00 || zhuzhu | 2018-02-05 | 2200.00 || gougou | 2018-02-05 | 2200.00 || tom | 2018-02-03 | 5000.00 || tianyun | 2018-02-02 | 600.00 || jack | 2018-02-02 | 5000.00 || harry | 2018-02-02 | 6000.00 || alice | 2018-02-02 | 7200.00 || robin | 2018-02-02 | 8000.00 |+-----------+------------+----------+10 rows in set (0.00 sec) 4限制查询的记录数只显示排序后公司薪资最高的前5位员工 从0开始查询,共查询5条 1234567891011mysql&gt; mysql&gt; select name,salary from employee5 order by salary desc limit 0,5;+-------+----------+| name | salary |+-------+----------+| emma | 20000.00 || robin | 8000.00 || alice | 7200.00 || harry | 6000.00 || jack | 5000.00 |+-------+----------+5 rows in set (0.00 sec) 5使用集合函数查询 函数 描述 count() 统计数量 max() 最大值 min 最小值 avg 平均值 sum 总和值 123456789101112131415mysql&gt; select count(*) from employee5;+----------+| count(*) |+----------+| 10 |+----------+1 row in set (0.00 sec)mysql&gt; select count(*) from employee5 where post=&apos;hr&apos; ;+----------+| count(*) |+----------+| 1 |+----------+1 row in set (0.00 sec) 1234567891011121314mysql&gt; select max(salary) from employee5;+-------------+| max(salary) |+-------------+| 20000.00 |+-------------+1 row in set (0.00 sec)mysql&gt; select max(salary) from employee5 where job_description=&apos;teach&apos;;+-------------+| max(salary) |+-------------+| 8000.00 |+-------------+1 row in set (0.00 sec) 1234567mysql&gt; select min(salary) from employee5 where job_description=&apos;teach&apos;;+-------------+| min(salary) |+-------------+| 600.00 |+-------------+1 row in set (0.00 sec) 1234567891011121314mysql&gt; select avg(salary) from employee5;+-------------+| avg(salary) |+-------------+| 5840.000000 |+-------------+1 row in set (0.00 sec)mysql&gt; select avg(salary) from employee5 where job_description=&apos;teach&apos;;+-------------+| avg(salary) |+-------------+| 5160.000000 |+-------------+1 row in set (0.00 sec) 1234567mysql&gt; select sum(salary) from employee5;+-------------+| sum(salary) |+-------------+| 58400.00 |+-------------+1 row in set (0.00 sec) 6分组查询group_concat()函数和group by()函数通常一块使用按照部门来分组 12345678910111213141516171819mysql&gt; mysql&gt; select post,group_concat(name) from employee5 group by post;+------------+------------------------------+| post | group_concat(name) |+------------+------------------------------+| hr | harry || instructor | jack,tom,robin,alice,tianyun || sale | emma,christine,zhuzhu,gougou |+------------+------------------------------+3 rows in set (0.00 sec)mysql&gt; select post,group_concat(salary) from employee5 group by post;+------------+----------------------------------------+| post | group_concat(salary) |+------------+----------------------------------------+| hr | 6000.00 || instructor | 5000.00,5000.00,8000.00,7200.00,600.00 || sale | 20000.00,2200.00,2200.00,2200.00 |+------------+----------------------------------------+3 rows in set (0.00 sec) group by()函数和集合函数一起使用123456789mysql&gt; select post,sum(salary),avg(salary),count(*) from employee5 group by post;+------------+-------------+-------------+----------+| post | sum(salary) | avg(salary) | count(*) |+------------+-------------+-------------+----------+| hr | 6000.00 | 6000.000000 | 1 || instructor | 25800.00 | 5160.000000 | 5 || sale | 26600.00 | 6650.000000 | 4 |+------------+-------------+-------------+----------+3 rows in set (0.00 sec) 7正则表达式查询 ‘^ali’—–以ali开头 ‘yun$’—-以yun结尾 ‘m{2}’—-m出现的次数 1234567mysql&gt; select name,salary from employee5 where name regexp &apos;m&#123;2&#125;&apos;;+------+----------+| name | salary |+------+----------+| emma | 20000.00 |+------+----------+1 row in set (0.00 sec) 小结对字符串匹配的方式 123where name = &apos;tom&apos;;where name like &apos;to%&apos;;where name regexp &apos;yun$&apos;; 补充:嵌套查询1234567mysql&gt; mysql&gt; select * from employee5 where salary = (select max(salary) from employee5);+----+------+--------+------------+------+-----------------+----------+--------+--------+| id | name | sex | hire_date | post | job_description | salary | office | dep_id |+----+------+--------+------------+------+-----------------+----------+--------+--------+| 8 | emma | female | 2018-02-06 | sale | salecc | 20000.00 | 503 | 102 |+----+------+--------+------------+------+-----------------+----------+--------+--------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql单表查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql多表查询]]></title>
    <url>%2F2019%2F09%2F04%2Fmysql%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[新建表1234567891011mysql&gt; create table employee6( -&gt; emp_id int auto_increment primary key, -&gt; emp_name varchar(50), -&gt; age int, -&gt; dept_id int);Query OK, 0 rows affected (0.18 sec)mysql&gt; create table department6( -&gt; dept_id int, -&gt; dept_name varchar(50));Query OK, 0 rows affected (0.17 sec) 插入数据12345678910111213mysql&gt; insert into employee6(emp_name,age,dept_id) values -&gt; (&apos;tianyun&apos;,19,200), -&gt; (&apos;tom&apos;,26,201), -&gt; (&apos;jack&apos;,30,202), -&gt; (&apos;alice&apos;,24,203), -&gt; (&apos;robin&apos;,40,204), -&gt; (&apos;narasha&apos;,28,205);Query OK, 6 rows affected (0.01 sec)Records: 6 Duplicates: 0 Warnings: 0mysql&gt; insert into department6 values(200,&apos;hr&apos;), (201,&apos;it&apos;), (202,&apos;sale&apos;), (203,&apos;fd&apos;);Query OK, 4 rows affected (0.01 sec)Records: 4 Duplicates: 0 Warnings: 0 查看表1234567891011121314151617181920212223mysql&gt; select * from employee6;+--------+----------+------+---------+| emp_id | emp_name | age | dept_id |+--------+----------+------+---------+| 1 | tianyun | 19 | 200 || 2 | tom | 26 | 201 || 3 | jack | 30 | 202 || 4 | alice | 24 | 203 || 5 | robin | 40 | 204 || 6 | narasha | 28 | 205 |+--------+----------+------+---------+6 rows in set (0.00 sec)mysql&gt; select * from department6;+---------+-----------+| dept_id | dept_name |+---------+-----------+| 200 | hr || 201 | it || 202 | sale || 203 | fd |+---------+-----------+4 rows in set (0.00 sec) 内连接(只连接匹配的行)123456789101112mysql&gt;select employee6.emp_id,employee6.emp_name, employee6.age, department6.dept_name -&gt;from employee6, department6 -&gt;where employee66.dept_id = department6.dept_id;+--------+----------+------+-----------+| emp_id | emp_name | age | dept_name |+--------+----------+------+-----------+| 1 | tianyun | 19 | hr || 2 | tom | 26 | it || 3 | jack | 30 | sale || 4 | alice | 24 | fd |+--------+----------+------+-----------+4 rows in set (0.00 sec) 可以简写为,但是如果该字段两张表都存在,则不能简写 12345678910mysql&gt; select emp_id,emp_name,age,dept_name from employee6, department6 where employee6.dept_id = department6.dept_id;+--------+----------+------+-----------+| emp_id | emp_name | age | dept_name |+--------+----------+------+-----------+| 1 | tianyun | 19 | hr || 2 | tom | 26 | it || 3 | jack | 30 | sale || 4 | alice | 24 | fd |+--------+----------+------+-----------+4 rows in set (0.00 sec) 发现只显示了有部门的员工 外连接左连接 以left join左面的表为准123456789101112mysql&gt; select emp_id,emp_name,age,dept_name from employee6 left join department6 on emplooyee6+--------+----------+------+-----------+| emp_id | emp_name | age | dept_name |+--------+----------+------+-----------+| 1 | tianyun | 19 | hr || 2 | tom | 26 | it || 3 | jack | 30 | sale || 4 | alice | 24 | fd || 5 | robin | 40 | NULL || 6 | narasha | 28 | NULL |+--------+----------+------+-----------+6 rows in set (0.00 sec) 右连接,以right join左面的表为准1234567891011121314mysql&gt; insert into department6 values(510,&apos;os&apos;);Query OK, 1 row affected (0.04 sec)mysql&gt; select emp_id,emp_name,age,dept_name from employee6 right join department6 on emplloyee6+--------+----------+------+-----------+| emp_id | emp_name | age | dept_name |+--------+----------+------+-----------+| 1 | tianyun | 19 | hr || 2 | tom | 26 | it || 3 | jack | 30 | sale || 4 | alice | 24 | fd || NULL | NULL | NULL | os |+--------+----------+------+-----------+5 rows in set (0.00 sec) 复合查询以内连接的方式查询employee6和department6表,并且employee6表中的age字段值需要大于25 找出公司部门中年龄大于25岁的员工 12345678mysql&gt; select emp_id,emp_name,age,dept_name from employee6, department6 where employee6.dept_id = department6.dept_id and age&gt;=25;+--------+----------+------+-----------+| emp_id | emp_name | age | dept_name |+--------+----------+------+-----------+| 2 | tom | 26 | it || 3 | jack | 30 | sale |+--------+----------+------+-----------+2 rows in set (0.00 sec) 以内连接的方式查询employee6和department6表,并且以age字段的升序显示12345678910mysql&gt; select emp_id,emp_name,age,dept_name from employee6, department6 where employee6.dept_id = department6.dept_id order by age;+--------+----------+------+-----------+| emp_id | emp_name | age | dept_name |+--------+----------+------+-----------+| 1 | tianyun | 19 | hr || 4 | alice | 24 | fd || 2 | tom | 26 | it || 3 | jack | 30 | sale |+--------+----------+------+-----------+4 rows in set (0.00 sec)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql多表查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql安全机制]]></title>
    <url>%2F2019%2F09%2F04%2Fmysql%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[登录 授权(创建)用户 回收权限 删除用户 修改密码 登录发现远程访问时无法登录mysql 123[root@VM_0_15_centos ~]# mysql -h106.54.3.104 -uroot -p&apos;qingdao@123&apos;mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 1130 (HY000): Host &apos;118.24.193.33&apos; is not allowed to connect to this MySQL server 登录参数 mysql -h192.168.5.240 -P 3306 -u root -p’123’ mysql -e ‘show table’ 参数 描述 默认 -h192.168.5.240 指定主机名 默认localhost -P 3306 指定端口 默认3306 -u root 用户 默认root -p’123’ 密码 默认空密码 mysql 进入的数据库 / -e ‘show table’ 指定的sql命令 / 授权(创建)用户 mysql库下面存放授权信息 user表存放—-全局权限 db表存放—-库级别权限 tables_priv表存放—-表级别授权 columns_priv表存放—-列级别授权 user表字段 描述 Host 主机 User 用户 max_questions 最大请求数 max_updates 最大更新数 max_connections 最大连接数 max_user_connections 最大用户连接数 authentication_string 密码 password_expired 密码过期情况 password_last_changed 密码上次更新 password_lifetime 密码生存周期 account_locked 账户锁 给某个用户授权时,如果该用户不存在,则会自动创建该用户.要指定密码 12mysql&gt; grant all on *.* to &apos;yang1&apos;@&apos;118.24.193.33&apos; IDENTIFIED BY &apos;mypass.123A&apos;;Query OK, 0 rows affected, 1 warning (0.00 sec) 12mysql&gt; grant all on company.* to &apos;zhuzhu1&apos;@&apos;118.24.193.33&apos; IDENTIFIED BY &apos;mypass.123B&apos;;Query OK, 0 rows affected, 1 warning (0.00 sec) 那么上面创建用户的命令都是在会把创建痕迹放在哪里呢? mysql&gt; select * from mysql.user\G 发现yang1用户的权限是全局级别权限可以在mysql.user表中查看到信息 mysql&gt; select * from mysql.db\G 发现zhuzhu1用户的权限是库级别权限可以在mysql.db表中查看到信息 表中Grant_priv: N字段不允许将该权限授权给其他用户 现在通过刚刚建立的两张表以及可以在另一台服务器上访问数据库了 设置的权限不同,能操作的范围也不同 123456789101112131415161718[root@VM_0_15_centos ~]# mysql -h106.54.3.104 -uyang1 -p&apos;mysql.123A&apos;Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || company || mysql || performance_schema || school || sumyum || sys || test1 |+--------------------+8 rows in set (0.03 sec)mysql&gt; 123456789101112[root@VM_0_15_centos ~]# mysql -h106.54.3.104 -uzhuzhu1 -p&apos;mypass.123B&apos;Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || company |+--------------------+2 rows in set (0.04 sec)mysql&gt; 权限管理grant设置权限 grant 权限列表 on 库名.表名 to ‘用户名‘@’客户端主机’ [identified by’密码’ with option参数] 权限列表 描述 all 所有权限 (不包括授权权限) select,update 指定权限 表名库名选项 描述 * . * 所有库下的所有表 web.* web库下的所有表 web.stu_info web库下的stu_info表 select(col1),insert(col1,col2) ON web.stu_info 对列赋予不同的权限 客户端主机 描述 % 所有主机 192.168.1.% 指定网段 192.168.1.22 指定主机 localhost 指定主机 对列赋予不同的权限 12mysql&gt; grant select(dept_name,dept_comment),insert(dept_name) on company.department1 to &apos;admin&apos;@&apos;%&apos; identified by &apos;qwQW123@#!!&apos;;Query OK, 0 rows affected, 1 warning (0.03 sec) 12[root@VM_0_15_centos ~]# mysql -h106.54.3.104 -uadmin -p&apos;qwQW123@#!!&apos;mysql&gt; use company; 12345mysql&gt; insert into department1(dept_name, dept_comment) values(&apos;tomp&apos;,&apos;tompfdfreger&apos;);ERROR 1143 (42000): INSERT command denied to user &apos;admin&apos;@&apos;118.24.193.33&apos; for column &apos;dept_comment&apos; in table &apos;department1&apos;mysql&gt; insert into department1(dept_name) values(&apos;tomp&apos;);Query OK, 1 row affected (0.07 sec) 查看权限show grants for查看当前权限 1234mysql&gt; show grants\GGrants for admin@%: GRANT SELECT (dept_comment, dept_name), INSERT (dept_name) ON `company`.`department1` TO &apos;admin&apos;@&apos;%&apos;2 rows in set (0.03 sec) 查看指定用户权限 1234mysql&gt; show grants for &apos;admin&apos;@&apos;%&apos;\GGrants for admin@%: GRANT SELECT (dept_comment, dept_name), INSERT (dept_name) ON `company`.`department1` TO &apos;admin&apos;@&apos;%&apos;2 rows in set (0.03 sec) 回收权限回收某一个用户的权限时,可以先查看权限,然后复制,将to改为from 回收全部权限回收admin 1234567mysql&gt; revoke SELECT (dept_comment, dept_name), INSERT (dept_name) ON `company`.`department1` from &apos;admin&apos;@&apos;%&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; show grants for &apos;admin&apos;@&apos;%&apos;\G*************************** 1. row ***************************Grants for admin@%: GRANT USAGE ON *.* TO &apos;admin&apos;@&apos;%&apos;1 row in set (0.00 sec) 回收yang1 123456789101112mysql&gt; show grants for &apos;yang1&apos;@&apos;118.24.193.33&apos;\G*************************** 1. row ***************************Grants for yang1@118.24.193.33: GRANT ALL PRIVILEGES ON *.* TO &apos;yang1&apos;@&apos;118.24.193.33&apos;1 row in set (0.00 sec)mysql&gt; revoke ALL PRIVILEGES ON *.* from &apos;yang1&apos;@&apos;118.24.193.33&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; show grants for &apos;yang1&apos;@&apos;118.24.193.33&apos;\G*************************** 1. row ***************************Grants for yang1@118.24.193.33: GRANT USAGE ON *.* TO &apos;yang1&apos;@&apos;118.24.193.33&apos;1 row in set (0.00 sec) 回收部分权限12mysql&gt; grant all on school.* to &apos;admin2&apos;@&apos;%&apos; identified by&apos;1q2w3eQWE!&apos;;Query OK, 0 rows affected, 1 warning (0.00 sec) 123456mysql&gt; show grants for &apos;admin2&apos;@&apos;%&apos;\G*************************** 1. row ***************************Grants for admin2@%: GRANT USAGE ON *.* TO &apos;admin2&apos;@&apos;%&apos;*************************** 2. row ***************************Grants for admin2@%: GRANT ALL PRIVILEGES ON `school`.* TO &apos;admin2&apos;@&apos;%&apos;2 rows in set (0.00 sec) 12mysql&gt; revoke insert ON `school`.* from &apos;admin2&apos;@&apos;%&apos;;Query OK, 0 rows affected (0.00 sec) 删除用户drop user 5.6版本删除用户前需要先拿掉权限 如果直接删除用户,权限还会存在 会造成如果下次创建同名用户,会继续使用删除之前的权限 5.7则不会 drop user 123456mysql&gt; show grants for &apos;admin2&apos;@&apos;%&apos;\G*************************** 1. row ***************************Grants for admin2@%: GRANT USAGE ON *.* TO &apos;admin2&apos;@&apos;%&apos;*************************** 2. row ***************************Grants for admin2@%: GRANT SELECT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, TRIGGER ON `school`.* TO &apos;admin2&apos;@&apos;%&apos;2 rows in set (0.00 sec) 12345mysql&gt; drop user &apos;admin2&apos;@&apos;%&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; show grants for &apos;admin2&apos;@&apos;%&apos;\GERROR 1141 (42000): There is no such grant defined for user &apos;admin2&apos; on host &apos;%&apos; 删除用户DELETE语句 修改用户密码root用户修改root用户密码方法1 1234[root@VM_0_7_centos ~]# mysqladmin -uroot -p&apos;qingdao@123&apos; password &apos;qingdao@123NEW&apos;mysqladmin: [Warning] Using a password on the command line interface can be insecure.Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety. 方法二 123mysql&gt; update mysql.user set authentication_string=password(&apos;qingdao@123NEW2&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1 使用这种方法需要刷新授权 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec) 方法三 12mysql&gt; set password=password(&apos;qingdao@123NEW3&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec) root用户修改普通用户密码方法一 12mysql&gt; set password for &apos;yang1&apos;@&apos;118.24.193.33&apos;=password(&apos;yang1!@#NEW1&apos;);Query OK, 0 rows affected, 1 warning (0.00 sec) 方法二参考上面方法二 普通用户修改普通用户密码set命令修改当前用户密码 忘记root密码5.7.6之后的版本在/etc/my.cnf配置文件中添加字段 12[root@VM_0_7_centos ~]# tail -n 1 /etc/my.cnfskip-grant-tables 重启服务 12[root@VM_0_7_centos ~]# service mysqld restartRedirecting to /bin/systemctl restart mysqld.service 现在可以无密码登录 1234567891011121314[root@VM_0_7_centos ~]# mysqlWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.27 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 查看密码表 123456789mysql&gt; select user,host,authentication_string from mysql.user;+---------------+-----------+-------------------------------------------+| user | host | authentication_string |+---------------+-----------+-------------------------------------------+| root | localhost | *A32A774CFD115F70CC83AB40D7A4F9E4AA9E8DD3 || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |+---------------+-----------+-------------------------------------------+3 rows in set (0.00 sec) 重置密码 123mysql&gt; update mysql.user set authentication_string=password(&apos;qingdao@123&apos;) where user=&apos;root&apos;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1 退出mysql 12mysql&gt; \qBye 注释skip-grant-tables字段 12[root@VM_0_7_centos ~]# tail -n 1 /etc/my.cnf# skip-grant-tables 重启mysql服务 12[root@VM_0_7_centos ~]# service mysqld restartRedirecting to /bin/systemctl restart mysqld.service 登录mysql 123456789101112131415[root@VM_0_7_centos ~]# mysql -uroot -p&apos;qingdao@123&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.27 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 5.7.6之前的怎么操作呢只有两个区别5.7.6之前的可以设置简单密码5.7.6之前的版本需要将authentication_string字段改为password字段]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql安全机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql表完整性约束]]></title>
    <url>%2F2019%2F09%2F04%2Fmysql%E8%A1%A8%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[表完整性约束作用,用于保证数据的完整性和一致性|约束条件|说明||-|-||primary key|标识该字段为该表的主键,可以唯一的标识记录,不可以为空||foreing key|标识该字段为表的外键,实现表与表之间的关联||not null|标识该字段不能为空||unique key|标识该字段的值是唯一的,可以为空,一个表可以有多个unique key||auto_increment|标识该字段的值是自动增长(整数类型,而且是主键)||default|为该字段设置默认值||unsigned|无符号,正数||zerofill|使用0填充,例如000000001| default(默认值)和not null(是否允许空值) 默认值不允许为函数 NULL值就是没有值或缺值 允许NULL值的列，就是允许在插入行时不给出该列的值 不允许NULL值的列在插入或更新行时，该列必须有值 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。 如果指定‘’两个单引号，其间没有字符，这在NOT NULL列是允许的123456789mysql&gt; use test1;Database changedmysql&gt; create table student4( -&gt; id int not null, -&gt; name varchar(50) not null, -&gt; sex enum(&apos;m&apos;,&apos;f&apos;) default &apos;m&apos; not null, -&gt; age int unsigned default 18 not null, -&gt; hobby set(&apos;disc&apos;,&apos;book&apos;,&apos;music&apos;) default &apos;disc,book&apos; not null);Query OK, 0 rows affected (0.19 sec) 1234567891011mysql&gt; desc student4;+-------+----------------------------+------+-----+-----------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------------------------+------+-----+-----------+-------+| id | int(11) | NO | | NULL | || name | varchar(50) | NO | | NULL | || sex | enum(&apos;m&apos;,&apos;f&apos;) | NO | | m | || age | int(10) unsigned | NO | | 18 | || hobby | set(&apos;disc&apos;,&apos;book&apos;,&apos;music&apos;) | NO | | disc,book | |+-------+----------------------------+------+-----+-----------+-------+5 rows in set (0.00 sec) unique key(唯一) 可以为空,但是不允许重复 1234mysql&gt; create table department1( -&gt; dept_in int, -&gt; dept_name varchar(50) unique, -&gt; dept_comment varchar(100) ); unique可以在列名的最后指定,也可以在最后指定 12345mysql&gt; create table department2( -&gt; id int, -&gt; name varchar(50), -&gt; comment varchar(100), -&gt; unique(name)); AUTO_INCREMENT AUTO_INCREMENT告诉mysql，本列每增加一行时自动增量，每次执行一个INSERT操作时，MYSQL自动对该列增量（从而才有了AUTO_INCREMENT），给该列赋予下一个可用的值，这样给每个行分配一个唯一的cust_id,从而可以用作主键值 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（通常使它成为主键） 可以通过SELECT last_insert_id()语句来获取最后一个AUTO_INCREMENT主键 单列做主键 多列做主键(复合主键) primary key字段的值是不允许重复,且不允许为null 123456mysql&gt; create table student6( -&gt; id int primary key not null auto_increment, -&gt; name varchar(50) not null, -&gt; sex enum(&apos;male&apos;,&apos;female&apos;) not null default &apos;male&apos;, -&gt; age int not null default 18);Query OK, 0 rows affected (0.18 sec) 插入数据 123456mysql&gt; insert into student6(name,sex,age) values -&gt; (&apos;jack&apos;,&apos;male&apos;,17), -&gt; (&apos;alice&apos;,&apos;female&apos;,23), -&gt; (&apos;tianyun&apos;,&apos;male&apos;,40);Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0 1234567mysql&gt; select * from student6;+----+---------+--------+-----+| id | name | sex | age |+----+---------+--------+-----+| 1 | jack | male | 17 || 2 | alice | female | 23 || 3 | tianyun | male | 40 | 主键不能重复 12mysql&gt; insert into student6 values(2,&apos;harry&apos;,&apos;male&apos;,17);ERROR 1062 (23000): Duplicate entry &apos;2&apos; for key &apos;PRIMARY&apos; 复合主键场景:单列不能证明唯一性,需要使用多列创建|设置主键为:|host_ip+port=primary key)||-|-||host_ip | 存储主机IP||service_name | 服务名||port | 服务对应的端口||allowy(y,n) | 服务是否允许访问| 1234567mysql&gt; create table service( -&gt; ip varchar(15) not null, -&gt; service varchar(16) not null, -&gt; port int not null, -&gt; pritocol enum(&apos;tcp&apos;,&apos;udp&apos;) default &apos;tcp&apos;, -&gt; allow enum(&apos;y&apos;,&apos;n&apos;) default &apos;n&apos;, -&gt; primary key(ip,port)); 插入数据 12345678mysql&gt; insert into service values(&apos;192.168.122.223&apos;,&apos;http&apos;,80,&apos;tcp&apos;,&apos;y&apos;);Query OK, 1 row affected (0.04 sec)mysql&gt; insert into service(ip,service,port) values(&apos;192.168.122.223&apos;,&apos;ftp&apos;,21);Query OK, 1 row affected (0.02 sec)mysql&gt; insert into service values(&apos;192.168.122.220&apos;,&apos;http&apos;,80,&apos;tcp&apos;,&apos;y&apos;);Query OK, 1 row affected (0.03 sec) 123456789mysql&gt; select * from service;+-----------------+---------+------+----------+-------+| ip | service | port | pritocol | allow |+-----------------+---------+------+----------+-------+| 192.168.122.220 | http | 80 | tcp | y || 192.168.122.223 | ftp | 21 | tcp | n || 192.168.122.223 | http | 80 | tcp | y |+-----------------+---------+------+----------+-------+3 rows in set (0.00 sec) foreign key(外键) 存储引擎必须是innodb 用子表的外键关联父表的主键,这两个字段的名称,数据类型和约束都需要相同 foreign key(name) —- 设置当前表的外键为name references employees(name) —-关联employees表的name字段 on update cascade —- 同步更新 on delete cascade —- 同步删除 设置父表company.employees 12345mysql&gt; create table employees( -&gt; name varchar(50) not null, -&gt; mail varchar(20), -&gt; primary key(name));Query OK, 0 rows affected (0.17 sec) 设置字表company.payroll 1234567mysql&gt; create table payroll( -&gt; id int auto_increment, -&gt; name varchar(50) not null, -&gt; payroll float(8,2) not null, -&gt; primary key(id), -&gt; foreign key(name) references employees(name) on update cascade on delete cascade);Query OK, 0 rows affected (0.24 sec) 向父表员工表中插入值 123456mysql&gt; desc employees;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| name | varchar(50) | NO | PRI | NULL | || mail | varchar(20) | YES | | NULL | | 123456mysql&gt; insert into employees values -&gt; (&apos;jack&apos;,&apos;jack@163.com&apos;),(&apos;alice&apos;,null);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0``` **向子表薪水表中插入数据** mysql&gt; insert into payroll(name,payroll) values(‘alice’,20000);Query OK, 1 row affected (0.03 sec) mysql&gt; insert into payroll(name,payroll) values(‘tianyun’,25300);ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (company.payroll, CONSTRAINT payroll_ibfk_1 FOREIGN KEY (name) REFERENCES employees (name) ON DELETE CASCADE ON UPDATE CASCADE) 12345&gt; 发现员工表中没有tianyun,所有在薪水表中无法添加**主表中更改name名称,发现子表中name值也改变了** mysql&gt; update employees set name=’alice123’ where name=’alice’;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 12345678```mysql&gt; select * from payroll;+----+----------+----------+| id | name | payroll |+----+----------+----------+| 2 | alice123 | 20000.00 |+----+----------+----------+1 row in set (0.00 sec) 删除员工表中一位员工,发现新水表中该员工也会自动删除 12345mysql&gt; delete from employees where name=&apos;alice123&apos;;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from payroll;Empty set (0.00 sec)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据类型]]></title>
    <url>%2F2019%2F09%2F01%2Fmysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型 数据类型是定义列中可以存储什么数据以及 该数据怎样存储的基本规则在设计表时，应该特别重视所用的数据类型。使用错误的数据类型，可能会严重地影响应用程序的功能和性能。更改包含数据的列不是一件小事（数据还有可能丢失） 1字符串数据类型最常用的数据类型是串数据类型|数据类型|说明||-|-||CHAR|1-255个字符的定长串，它的长度必须在创建时指定，否则mysql假定为CHAR(1)||ENUM|接受最多64个串组成的一个预定义集合的某个串||LONGTEXT|与TEXT相同，但最大长度为4GB||MEDIUMTEXT| 与TEXT相同，但最大长度为16K||SET| 接受最多64个串组成的一个预定义集合的零个串或多个串||TEXT|最大长度为64K的边长文本||TINYTEXT|与TEXT相同，最大长度为255字节||VARCHAR|长度可变，最多不超过255字节。如果在创建时指定为varchar(n).则可以存储0到n个字符的边长串（n&lt;=255)| 有两种基本的串类型，分别为定长串和变长串 定长串接受长度固定的字符串，其长度是在创建表时指定的。定长串不允许多余指定的字符数目，它们分配的存储空间和指定的一样多CHAR属于定长串 变长串存储可变长的文本，有些变长数据类型具有最大的定长。而有些是完全变长的TEXT,VARCHAR属于变长型 从资源节约角度来看,用的VARCHAR较多,用多少申请多少,而不是最开始指定 char(5)是限制长度为5个字符123456789mysql&gt; create table t8(c char(5), v varchar(5));Query OK, 0 rows affected (0.19 sec)mysql&gt; insert into t8 values(&apos;qwerd&apos;,&apos;qwerdf&apos;);ERROR 1406 (22001): Data too long for column &apos;v&apos; at row 1mysql&gt; insert into t8 values(&apos;qwerdf&apos;,&apos;qwerd&apos;);ERROR 1406 (22001): Data too long for column &apos;c&apos; at row 1mysql&gt; insert into t8 values(&apos;qwerd&apos;,&apos;qwerd&apos;);Query OK, 1 row affected (0.02 sec) 在检索时,char列会删除尾部的空格,varchar会保留空格1234567891011mysql&gt; insert into t8 values(&apos;q &apos;,&apos;q &apos;);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select length(c),length(v) from t8;+-----------+-----------+| length(c) | length(v) |+-----------+-----------+| 5 | 5 || 1 | 5 |+-----------+-----------+2 rows in set (0.00 sec) 不管使用何种形式的串数据类型，都必须阔在引号内（通常单引号更好）电话号码和邮政编码应该存储在串数据类型中。（如果存储在数值字段中开头为0，实际上会丢失一位数字） 2数值数据类型 数据类型 说明 BIT 位字段，1~64位 BIGINT 整数型，支持-9223372036854775808+9223372036854775807 （如果是UNSIGNED，为018446744073709551615）的数 BOOLEAN（或BOOL） 布尔，或者为0或者为1，主要用于on/off DECIMAL （或DEC DOUBLE 双精度浮点型 FLOAT 单精度浮点型 INT（或INTEFER） 整数型，支持-2147483648+2147483647（如果是UNSIGNED，为04294967295）的数 MEDIUMINT 整数型，支持-83886088388607（如果是UNSIGNED，为016777215）的数 REAL 4字节的浮点值 SMALLINT 整数值，支持-3276835767（如果是UNSIGNED，为065535）的数 TINYINT 整数型，支持-128到127（如果是UBSIGNED），为（0~255）的数 数值不应该括在引号内除BIT和BOOLEAN外，其余所有数值数据类型都可以有符号或无符号没有专门存储货币的数据类型，一般情况下使用DECIMAL（8，2） 常用数值数据类型 int(常规整形) tinyint(最小整形) 12mysql&gt; create table test1(tinyint_test tinyint,int_test int);Query OK, 0 rows affected (0.21 sec) 12345678910mysql&gt; desc test1;+--------------+------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------+------------+------+-----+---------+-------+| tinyint_test | tinyint(4) | YES | | NULL | || int_test | int(11) | YES | | NULL | |+--------------+------------+------+-----+---------+-------+2 rows in set (0.01 sec)mysql&gt; 插入数据(dml) 12mysql&gt; insert into test1 values(&apos;111&apos;,&apos;111&apos;);Query OK, 1 row affected (0.03 sec) 查看 123456789mysql&gt; select * from test1;+--------------+----------+| tinyint_test | int_test |+--------------+----------+| 111 | 111 |+--------------+----------+1 row in set (0.00 sec)mysql&gt; 指定行插入数据(超出范围插入失败) 1234567mysql&gt; insert into test1(tinyint_test) values(128);ERROR 1264 (22003): Out of range value for column &apos;tinyint_test&apos; at row 1mysql&gt; insert into test1(tinyint_test) values(127);Query OK, 1 row affected (0.02 sec)mysql&gt; 在此基础上添加无符号约束12mysql&gt; create table test2(tinyint_test tinyint unsigned,int_test int unsigned);Query OK, 0 rows affected (0.19 sec) 发现添加unsigned后发现,tinyint数值类型可以支持到255 12mysql&gt; insert into test2(tinyint_test) value(255);Query OK, 1 row affected (0.03 sec) 但是添加unsigned后不支持输入负数 12345mysql&gt; insert into test2(tinyint_test) value(-1);ERROR 1264 (22003): Out of range value for column &apos;tinyint_test&apos; at row 1mysql&gt; insert into test1(tinyint_test) value(-1);Query OK, 1 row affected (0.03 sec) 设置宽度1234567mysql&gt; create database school;Query OK, 1 row affected (0.00 sec)mysql&gt; use school;Database changedmysql&gt; create table ti(id1 int,id2 int(8));Query OK, 0 rows affected (0.19 sec) 12345678910mysql&gt; insert into ti values(123456789,123456789);Query OK, 1 row affected (0.04 sec)mysql&gt; select * from ti;+-----------+-----------+| id1 | id2 |+-----------+-----------+| 123456789 | 123456789 |+-----------+-----------+1 row in set (0.00 sec) 再次添加限制zerofill用零填充 12mysql&gt; create table t2(id1 int zerofill,id2 int(8) zerofill);Query OK, 0 rows affected (0.19 sec) 12345mysql&gt; insert into t2 values(123456789,123456789);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t2 values(1,1);Query OK, 1 row affected (0.01 sec) 12345678mysql&gt; select * from t2;+------------+-----------+| id1 | id2 |+------------+-----------+| 0123456789 | 123456789 || 0000000001 | 00000001 |+------------+-----------+2 rows in set (0.00 sec) 整形的宽度仅为显示宽度,不是限制,因此建议整形无须指定宽度 浮点型 用于存储用户的身高,体重,薪水等 float(5,2)标示一共5位,小数占2位 12 mysql&gt; create table t3(float_test float(5,2));Query OK, 0 rows affected (0.18 sec) 12345 mysql&gt; insert into t3 values(10.12);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t3 values(219.123);Query OK, 1 row affected (0.02 sec) 12345678mysql&gt; select * from t3;+------------+| float_test |+------------+| 10.12 || 219.12 |+------------+2 rows in set (0.00 sec) 定点型12mysql&gt; create table t4(decimal_test decimal(5,2));Query OK, 0 rows affected (0.21 sec) 1234567891011121314mysql&gt; insert into t4 values(70.245);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; insert into t4 values(70.244);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from t4;+--------------+| decimal_test |+--------------+| 70.25 || 70.24 |+--------------+2 rows in set (0.00 sec) 日期和时间数据类型 数据类型 说明 DATE 表示日期，格式为YYYY-MM-DD TIME 格式为HH：MM：ss DATETIME DATE和TIME的组合 TIMESTAMP 功能和DATETIME相同，但范围较小 YEAR 用2位数字表示，范围是70（1970）-69（2069）；用4位数字表示，范围是1901~2155 12mysql&gt; create table t5(d date, t time, dt datetime);Query OK, 0 rows affected (0.20 sec) now()函数返回当前时间1234567mysql&gt; select now();+---------------------+| now() |+---------------------+| 2019-10-08 20:41:20 |+---------------------+1 row in set (0.00 sec) 插入当前时间12345678910mysql&gt; insert into t5 values(now(), now(), now());Query OK, 1 row affected, 1 warning (0.02 sec)mysql&gt; select * from t5;+------------+----------+---------------------+| d | t | dt |+------------+----------+---------------------+| 2019-10-08 | 20:43:10 | 2019-10-08 20:43:10 |+------------+----------+---------------------+1 row in set (0.00 sec) 时间戳12345678910mysql&gt; create table t6(id timestamp);Query OK, 0 rows affected (0.21 sec)mysql&gt; desc t6;+-------+-----------+------+-----+-------------------+-----------------------------+| Field | Type | Null | Key | Default | Extra |+-------+-----------+------+-----+-------------------+-----------------------------+| id | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |+-------+-----------+------+-----+-------------------+-----------------------------+1 row in set (0.01 sec) 默认是当前时间,插入null值时,会插入当前时间 12345678910mysql&gt; insert into t6 values(null);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from t6;+---------------------+| id |+---------------------+| 2019-10-08 20:51:30 |+---------------------+1 row in set (0.00 sec) 注意事项 插入年份时,尽量使用4位值 插入两位时, &lt;=69,以20开头,如2052 =70,以19开头,如1982 12mysql&gt; create table t7(y year);Query OK, 0 rows affected (0.19 sec) 1234567891011121314151617181920mysql&gt; insert into t7 values(69);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t7 values(70);Query OK, 1 row affected (0.02 sec)mysql&gt; insert into t7 values(2019);Query OK, 1 row affected (0.02 sec)mysql&gt; select * from t7;+------+| y |+------+| 2069 || 1970 || 2019 |+------+3 rows in set (0.00 sec)mysql&gt; 枚举和集合 enum 枚举.只能在给定的范围内选一个值,如男/女 set 集合,在给定的范围内选择一个或一个以上的值 新建数据表 12mysql&gt; create table student1(name varchar(50), sex enum(&apos;m&apos;,&apos;f&apos;), hobby set(&apos;book&apos;,&apos;music&apos;,&apos;disc&apos;,&apos;game&apos;));Query OK, 0 rows affected (0.19 sec) 123456789mysql&gt; desc student1;+-------+-----------------------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------------------------------+------+-----+---------+-------+| name | varchar(50) | YES | | NULL | || sex | enum(&apos;m&apos;,&apos;f&apos;) | YES | | NULL | || hobby | set(&apos;book&apos;,&apos;music&apos;,&apos;disc&apos;,&apos;game&apos;) | YES | | NULL | |+-------+-----------------------------------+------+-----+---------+-------+3 rows in set (0.00 sec) 插入值 12345678910mysql&gt; insert into student1 values(&apos;tom&apos;,&apos;m&apos;,&apos;disc,game&apos;);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from student1;+------+------+-----------+| name | sex | hobby |+------+------+-----------+| tom | m | disc,game |+------+------+-----------+1 row in set (0.00 sec) 二进制数据类型二进制数据类型可以存储任何类型，如图像，多媒体，字处理文档等 数据类型 说明 BLOB blob最大长度位64KB MEDIUMBLOB blob最大长度位16MB LONGBLOB blob最大长度位4GB TINYBLOB blob最大长度位255字节]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysql数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-xfs文件系统备份]]></title>
    <url>%2F2019%2F07%2F07%2Flinux-xfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[1初始xfs centos选择xfs格式作为默认文件系统，不再使用ext，但是仍然支持ext4提供xfsdump和xfsrestore工具xfs使用时，不需要卸载。 类似热备功能。支持断点续传 ####概念补充 完全备份：每次都把制定的本分目录完整的复制一遍增量本分：每次将之前做过的备份之后有变化的文件进行备份差异备份：每次将第一次完整备份以来有变化的文件进行备份 xfsdump的备份级别有两种 默认为0,0代表完全备份，1-9级别代表 增量备份 2xfs文件系统的使用1在虚拟机增加一块虚拟硬盘，开机之后会发现ls /dev/sdb 2对sdb分区 12345678fdisk /dev/sdb p:查看当前分区表 n：新建分区 P：主分区 e：扩展分区 其后会选择分区号和起始扇区，一般默认即可 设置扇区大小，根据情况设置 w：保存 3格式化mkfs.xfs /dev/sdb1 4创建挂载点mkdir /sdb1 5挂载mount /dev/sdb1 /sdb1 3完全备份与恢复#####1备份语法 12xfsdump -f 备份存放位置 要备份路径xfsdump -f /opt/dump_sdb1 /dev/sdb1 要备份的路径不能写成/sdb1/, 可以是/dev/sdb1 或者是 /sdb1 接下来会提示你:输入指定备份会话标签:dump_sdb1输入指定设备标签:sdb1 #####2免交互备份(方便后期定时操作) xfsdump -f /opt/dump_passwd /sdb1 -L dump_passwd -M sdb1 备份时,只备份某一个目录或者文件xfsdump -f /opt/dump_grub2 -s grub2/grub.cfg /boot -L dump_grub2 -M boot #####3完全备份恢复 查看备份详细信息xfsdump -I 文件系统恢复xfsrestore -f /opt/dump_sdb1 /sdb1 指定文件恢复xfsrestore -f /opt/dump_grub2 -s grub2/grub.cfg /boot 4增量备份 增量备份是指在一次全备份后，以后每次备份只需要备份与前一次相比增加或者修改的文件 优点 没有重复的文件，所有备份时间短，不会浪费存储空间缺点数据恢复相对麻烦，按照全备份到依次增量备份的时间，逐个反推。 实战，增量备份文件系统1对要备份的目录进行完全备份xfsdump -f /opt/test-full /sdb1 -L test-full -M sdb1 2对/sdb1 目录下增加一些文件或者内容，然后进行第一次增量备份xfsdump -l 1 -f /opt/test-full1 /sdb1 -L test-full1 -M sdb1 3继续对sdb1 目录下增加一些文件或者内容，进行第二次增量备份xfsdump -l 2 -f /opttest-full2 /sdb1 -L test-full2 -M sdb2 删除/sdb1目录的文件之后，如何恢复呢1恢复完全备份xfsrestore -f /opt/test-full /sdb1 2恢复1级备份xfsrestore -f /opt/test-full1 /sdb1 3恢复2级备份xfsrestore -f /opt/test-full2 /sdb2]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>xfs文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-文件的管理和查看]]></title>
    <url>%2F2019%2F07%2F07%2Flinux-%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[文件的管理和查看目录和文件的基本管理1mkdir** 语法: mkdir [选项] 目录名作用:创建目录选项:** -p: 递归创建 1234[root@meditation ~]# mkdir -p ./aa/bb[root@meditation ~]# tree ./aa./aa`-- bb 2cd** 语法: cd [目录]作用:切换目录** 简化操作 cd ~ : 进入当前用户的家目录 cd ../.. : 进入上两级目录 cd - : 进入上次目录 cd . : 进入当前目录 3相对路径和绝对路径扩展1相对路径 参照当前所在目录,进行查找cd ../usr/local/src/ 扩展2绝对路径 从根目录进行指定,一级一级进行递归查找.任何目录下,都能够进入到指定位置cd /etc/local/ 4touch** 语法: touch 文件名作用: 创建空文件** 123touch 文件1 文件2 #批量创建文件touch files&#123;1..5&#125; #创建files1到files5 5个文件touch -d “20190101 21:30” file.txt #指定创建时间 5rm -rf** 语法: rm -rf [文件或者目录]功能: 删除文件或者目录选项** -r: 删除目录 -f: 强制删除 6cp** 语法: cp [选项] [源文件或目录] [目标目录]作用: 复制文件或者目录选项** -r 复制目录 -p 连带文件属性目录 -d 若源文件是连接文件,则复制连接属性 -d 相当于-rpd 7mv** 语法: mv [源文件或目录] [目标目录]作用:重命名或者剪切文件** 如果源文件和目标文件在同一目录下,就是重命名.否则就是移动 8硬链接vs软链接** 语法: ln [选项] [源文件] [目标文件]选项** 不加选项,创建硬链接 -s : 创建软链接 硬链接特征(为一个文件又打开了一扇门) 1234拥有相同的i节点,和存储block,可以看做是同一个文件可以通过i节点识别不能跨分区不能针对目录使用 软连接特征 12345类似window上的快捷方式软链接拥有自己的i节点,和存储block,但是数据块中只保存原文件的文件名和i节点号,并没有实际的文件数据软链接的文件权限为|rwxrwxrwx 用原文件的权限来限制软链接的权限修改任意文件,另一个都能改变删除原文件,软链接不能使用 查看文件1cat** 语法 cat 文件名作用:查看文件内容,一次显示整个文件的内容** 123456[root@meditation ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 2more** 语法 more 文件名作用:查看文件内容,逐行显示内容说明:不支持前后翻滚.按回车刷新一行,空格刷新一屏幕,q退出** 1234567[root@meditation ~]# more /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin--More--(61%) 3less** 语法 less 文件名作用:支持前后翻滚. pageup向上翻页.pagedown向下翻页,按回车刷新一行,空格刷新一屏幕,q退出** 123456root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin/etc/passwd 4head** 语法 head 选项 文件名作用:用于显示文件开头的内容,默认显示10行内容** 1234567[root@meditation ~]# head -n 5 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin[root@meditation ~]# 5tail** 语法 tail 选项 文件名作用:用于显示文件结尾的内容,默认显示10行内容选项** -n 显示多少行内容 -f 动态显示内容(用于查看日志) 1234567[root@meditation ~]# tail -n 5 /etc/passwdjfedu2:x:1001:1001::/home/jfedu2:/bin/bashsunlizhao:x:1002:1002::/home/sunlizhao:/bin/bashsunlizhao31:x:1003:1003::/home/sunlizhao31:/bin/bashzarafa:x:995:993:Zarafa Service Account:/var/lib/zarafa:/sbin/nologinftpuser:x:1004:1004::/home/ftpuser:/sbin/nologin[root@meditation ~]#]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>命令行命令</tag>
        <tag>基础命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量]]></title>
    <url>%2F2019%2F06%2F28%2F%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量简介 变量是shell传递数据的一种方法 我们可以吧变量当成一个容器,通过变量可以在内存中存储数据,也可以在脚本执行中修改和访问存储的数据 变量有数字,字母,和下划线组成,区分大小写, 不能以数字开头 等号用于变量分配,在使用过程中等号两边不能有空格 当对变量赋值的类型是字符串时,需要用引号括起来 要对变量进行调用时,在变量名前加美元符号$ 分类变量分类 作用分类 1用户自定义变量, 2环境变量,主要保存的是和系统操作环境相关的数据 3位置参数变量,这种变量主要用来向脚本当中床底参数或数据,变量名不能自定义,变量作用是固定的 4预定义变量,是bash中已经定义好的变量,变量名不能自定义,变量作用也是固定的 变量作用域分类 全局变量,是环境变量,值不随着shell脚本的执行结束而消失 局部变量是shell程序内部定义的,其使用范围仅限于定义它的程序,对其他程序不可见,包括:自定义变量,位置参数变量,预定义变量 用户自定义变量规则 变量名由字母,数字,下划线组成, 不允许使用数字开头,等号两边不允许有空格 区分大小写 在使用变量时,在变量名前加$ 举例例1,等号两边不能有空格 12345[root@meditation ~]# var1 = 123-bash: var1: command not found[root@meditation ~]# var1=123[root@meditation ~]# echo $var1123 例2,变量值的叠加,使用${} $name是${name}的简化版本,在某些情况下,还必须使用花括号引起的方法来消除歧义 12345[root@meditation ~]# var2=mysql[root@meditation ~]# echo $var2db.log.log[root@meditation ~]# echo $&#123;var2&#125;db.logmysqldb.log 例3,命令的替换,使用$()或者反引号) 123456[root@meditation ~]# echo $date[root@meditation ~]# echo $(date &quot;+%F&quot;)2019-06-28[root@meditation ~]# echo `date &quot;+%F&quot;`2019-06-28 例4,命令的嵌套使用$( $()) 12[root@meditation ~]# var3=$(tar zcvf sh.tar.gz $(find /root/*.sh))tar: 从成员名中删除开头的“/” shell中单引号和双引号的区别 单引号之间的内容原封不动赋值给变量,双引号之间的内容如有特殊符号会保留它的特殊含义 ‘’ 所见即所得,原样输出. “” 如果内容中有命令，变量等，会先把变量，命令解析出结果，然后在输出最终内容来。 1234[root@meditation ~]# echo &apos;this is $var2&apos;this is $var2[root@meditation ~]# echo &quot;this is $var2&quot;this is mysql \ 转义符,跟在\后面的特殊符号将失去特殊含义,变为普通字符 1234[root@meditation ~]# echo $var2mysql[root@meditation ~]# echo \$var2$var2 删除变量1234[root@meditation ~]# unset var2[root@meditation ~]# echo $var2[root@meditation ~]# 环境变量在bash shell中,环境变量分为两类,全局变量和局部变量 全局变量:对于shell会话和所有的子shell都是可见的 局部变量:它只在自己的进程中 查看所有全局变量 1[root@meditation ~]# env export设置全局变量123456789[root@meditation ~]# var4=xuegod4[root@meditation ~]# export var5=xuegod5[root@meditation ~]# cat ./test.sh #!/bin/bashecho $var4echo $var5[root@meditation ~]# bash ./test.sh xuegod5 var4是局部变量,执行脚本时,重新打开了一个子shell,在这里面时获取不到的var5通过export设置为全局变量,在子shell中也是可见的 变量永久生效12[root@meditation ~]# env |grep var5var5=xuegod5 虽然我们设置了export全局变量,但是新开的xshell连接中,还是读不到变量var5让变量永久生效,可以把定义好的变量写入配置文件 当登录系统或新开一个ssh连接来启动bash进程时,会加载这4个配置文件 如果在多个文件中设置不同的值,以最后执行的文件为准 配置文件 描述 优先级 /etc/profile 系统全局环境和登录系统的一些配置 1 /etc/bashrc bash全局自定义配置文件,用于定义bash 2 /root/.bashrc 用于单独自定义某个用户的bash 3 /root/.bash_profile 用户单独自定义某个用户的系统环境 4 设置PATH环境变量 PATH变量是用来定义bash查找命令的目录当我们安装了第三方程序后,可以把第三方程序bin目录添加到这个PATH路径内,就可以在全局调用这个第三方程序 12345678910[root@meditation ~]# cat /opt/backup.sh #!/bin/bashecho &quot;Backup data is OK!&quot;[root@meditation ~]# chmod +x /opt/backup.sh [root@meditation ~]# backup.sh-bash: backup: command not found[root@meditation ~]# PATH=/opt/:$PATH[root@meditation ~]# backup.shBackup data is OK! 也可以将PATH=/opt/:$PATH加入到上述配置文件结尾处.source重新加载文件,即可生效 位置变量 $0 —- 代表命令本身 $1-9 —- 代表接受的第1-9个参数，10以上需要用{}括起来，比如${10}代表接收的第10个参数 $* —- 代表接收所有的参数，将所有参数看作一个整体 $@ —- 代表接收的所有参数，将每个参数区别对待 $# —- 代表接收的参数个数 12345678[root@meditation ~]# cat print.sh #!/bin/bashecho &quot;文件名:$0&quot;echo &quot;第一个参数:$1&quot;echo &quot;第二个参数:$2&quot;echo &quot;第三个参数:$3&quot;echo &quot;所有参数:$@&quot;echo &quot;总共参数数量:$#&quot; 1234567[root@meditation ~]# bash ./print.sh 1 2 3 4文件名:./print.sh第一个参数:1第二个参数:2第三个参数:3所有参数:1 2 3 4总共参数数量:4]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>变量</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lamp]]></title>
    <url>%2F2019%2F06%2F16%2Flamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[lamp linux+apache+mysql+php 安装lamp6 1yum -y install httpd mysql-service mysql php php-mysql 7 1yum -y install httpd mariadb-service mariadb php php-mysql 启动apache启动httpd服务 1systemctl start httpd 查看是否启动 1systemctl status httpd 添加到开机启动 1systemctl enable httpd 如果启动很慢 12345vim /etc/httpd/conf/httpd.conf修改字段\#ServerName www.example.com:80改为ServerName localhost:80 关闭centos7中的防火墙 1[root@localhost ~]# systemctl stop firewalld 通过浏览器输入虚拟机IP进行访问 启动数据库12systemctl start mariadb #启动服务systemctl enable mariadb #开机自启动 如果启动失败 1234Failed to start mariadb.service: Unit not found.# 可能是没有完全安装数据库yum install mariadb* 查看该服务使用的端口 12[root@localhost ~]# netstat -anput | grep mysqltcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 7938/mysqld mysql命令会进入数据库exit 退出数据库 12345[root@localhost ~]# mysqlMariaDB [(none)]&gt; MariaDB [(none)]&gt; exitBye[root@localhost ~]# 配置密码 有两种方法设置初始密码1配置安全向导（推荐）2设置root密码（不推荐） 安全配置向导 123456789[root@localhost ~]# mysql_secure_installation Enter current password for root (enter for none): #1回车设置root密码 ---回车Set root password? [Y/n] #2是否设置root密码 ---回车New password: #3设置root密码 ---123456&gt;回车Re-enter new password: #4确认root密码 ---123456&gt;回车Remove anonymous users? [Y/n] #5是否移除匿名用户 ---回车Disallow root login remotely? [Y/n] #6是否禁止root账号远程登录----回车Remove test database and access to it? [Y/n] #7是否移除test测试库 ---回车Reload privilege tables now? [Y/n] #8是否刷新权限授权表 ---回车 设置root密码 1mysqladmin -u root password &quot;123456&quot; 登录 123mysql -uroot -p123456或者mysql -uroot 测试php是否安装成功 1234567[root@localhost ~]# cat /var/www/html/index.php &lt;?php phpinfo()?&gt;You have new mail in /var/spool/mail/root[root@localhost ~]# systemctl restart httpd[root@localhost ~]# 访问]]></content>
      <categories>
        <category>lamp</category>
      </categories>
      <tags>
        <tag>网站</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-文本编辑器-vim]]></title>
    <url>%2F2019%2F06%2F16%2Flinux-vim%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一初始vim查看安装路径和安装的软件包 123456[root@VM_0_15_centos ~]# which vim/usr/bin/vim[root@VM_0_15_centos ~]# rpm -qf `which vim`vim-enhanced-7.4.160-2.el7.x86_64[root@VM_0_15_centos ~]# rpm -qf `which vi`vim-minimal-7.4.160-2.el7.x86_64 二vim编辑器模式间切换1vim编辑器模式介绍123command mode(命令模式) --&gt; edit mode(编辑模式)command mode(命令模式) --&gt; visual edit mode(视图编辑模式)command mode(命令模式) --&gt; extended command mode(扩展命令模式/末行模式) 2vim编辑器模式之间切换 模式之间切换需要先通过esc键进入命令模式 进入edit mode(编辑模式) 1234567i,在当前字符之前插入a,在当前字符之后插入o,在下一行插入I,行首插入A,行尾插入O,上一行插入 进入visual edit mode(视图编辑模式) 123v ---- 进入可视模式ctrl+v ---- 进入可视块模式V ---- 进入可视行模式 进入exiended command mode(扩展命令模式) 1: 3vim各模式的命令1command mode(命令模式)1.1光标定位 123456hjkl ---- 左下上右0和home键 ---- 切换到行首$和end键 ---- 切换到行尾gg ---- 定位到文档的首行 G ---- 定位到文档的末行ngg / nG ---- 自定义到某行 1.2查找关键字 1234/string ---- 查找关键字n ---- 向下查找N ---- 向上查找:noh ---- 退出查找 1.3文本编辑 12345678910复制yy ---- 复制光标所在行5yy ---- 复制5行剪切/删除dd ---- 删除光标所在行6dd ---- 删除6行粘贴p ---- 粘贴 1.4恢复 12u 将你的操作逐步撤销ctrl+r 将你的逐步撤销再逐步恢复 1.5其他命令 123x 删除光标所在字符r 替换光标所在字符D 从光标删除到行尾 2visual edit mode(视图编辑模式) 通过一个实例会比较容易理解 多行注释实例 1234561 光标先放在要注释的第一行的行首2 ctrl+v进入可视块模式3 向下移动光标,将注释的行都选中4 按大写的I5 插入你需要的内容,比如#6 按esc就会全部添加注释了 删除多行注释 1选中内容之后,按d,就会删除了 上述方法适用于所有批量操作场景 3extended command mode(扩展命令模式/末行模式)3.1保存退出 12345w 保存q 内容不改变时,退出wq 保存退出,常用q! 更改了内容之后,想回到上次保存时的状态e! 恢复到上一次保存时的状态 3.2文本替换/etc/passwd文件中,替换1-3行中每行出现的第一个bin进行替换为xue 1:1,3 s/bin/xue 1-3行全部的bin替换为xue 1:1,3 s/bin/xue/g 替换所有指定行的内容 1:5 s/bin/xue/g 全文范围,将xue改为bin,搜索时候,不区分大小写 1:% s/xue/bin/gi 4edit mode(编辑模式)略 扩展技巧扩展1 调用外部文件或者命令1.1调用外部命令 场景:写脚本时候想要写入网卡mac地址, 1234561)命令模式下输入 :!ifconfig2)手动复制ether 52:54:00:89:a0:9d3)编辑模式下右键选择 粘贴 1.2调用外部文件 12341)命令模式下输入 :r /etc/passwd2)会自动将passwd文件写入到当前文件 扩展2 vim异常退出 touch.txt文件异常退出,再次进入该文件会出现修复界面,该如何修复呢 1直接在修复界面输入命令 123456只读方式打开 O直接编辑 E恢复 R删除交换文件 D退出 Q中止 A 2在命令行通过命令恢复 123q退出该界面用命令修复vim -r touch.txt 补充 .touch.txt.swp文件保存着你上次意外退出还没有保存的文件上面两种方法都需要将.touch.txt.swp删除,否则会一直提示让你修复文件 扩展3 设置环境临时设置 1234:set nu 设置行号:set ic 不区分大小写:set list 显示控制字符:set nonu 取消设置行号 永久设置环境 12vim /etc/vimrc 设置后影响系统所有用户vim ~/.vimrc 用户家目录设置后,影响某一用户 在文件下添加内容 set nu 保存会生效 扩展4 打开两个文件左右方式打开两个文件 1vim -O /etc/passwd /etc/hosts 在两个文件中切换 1ctrl+ww 扩展5 比较两个文件有两个命令来对比两个文件,但vimdiff命令会列出两个文件来对比,更加直观 12345[root@VM_0_15_centos ~]# cp /etc/passwd /etc/mima[root@VM_0_15_centos ~]# echo hhhhhhh &gt;&gt; /etc/mima [root@VM_0_15_centos ~]# diff /etc/passwd /etc/mima 28a29&gt; hhhhhhh 123[root@VM_0_15_centos ~]# vimdiff /etc/passwd /etc/mima 2 files to edit:qa 退出两个文件]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>命令行编辑器</tag>
        <tag>文本编辑器</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-基础]]></title>
    <url>%2F2019%2F06%2F16%2Flinux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux基本命令操作一,历史概述1, 1969年 UNIX操作系统诞生,由贝尔实验室的Thompson(肯汤普森)和Dennis Ritchie(丹尼斯里奇) 2, 1972年 C语言诞生(汇编)3, 1973年 UNIX用C语言改写完成. 为了推广,开源,最为著名的是伯克利分校的BSD UNIX系统4, 1990年,朗讯认识到了UNIX的价值,起诉了很多厂商:IBM,HP5, 1991年,linux系统正式发布 谈到linux一定会知道Linux Kernel的创始人,Linux Benedict Torvalds(林纳斯本纳第克特托瓦兹),还要记住一个人,Richard Stallman(理查德斯托尔曼)他是自由软件运动的精神领袖,GNU计划及自由软件基金会的创立者,是著名黑客#&lt; GNU是GNU’S NOT UNIX的缩写 二,linux目录结构目录结构 1234567891011121314151617/ 处于linux系统树形结构的最顶端,是linux文件系统的入口/bin----常用的二进制命令目录,如ls,cp,mkdir等/boot----存放系统启动相关文件/dev----设备文件目录/etc----畅通系统及二进制安装包配置文件, 默认路径和服务器启动命令目录/home----普通用户的家目录,默认存放目录/mnt /media---- 一般用来临时挂载存储设备的挂载目录/opt----没什么用,可用自己用/proc----存在于内存中,是内存的映射,可以查看CPU信息,/pro/cpuinfo/sys----系统目录,存放硬件信息的相关文件/run----运行目录,存放系统运行时的数据,如进程PID文件/srv----服务目录,存放本地服务的相关文件/sbin----超级用户可执行命令存放目录/tmp----存放临时文件目录,只能被owner(拥有者)和超级权限删除/var----系统运行和软件运行时产生的日志信息/usr----存放应用程序和文件,自己安装存放位置/lib /lib64----都在/usr目录,存放系统最基本的动态,链接共享库,能够让程序正常编译运行,lib***.a是静态库, lib***.so是动态库 路径:表示文件的位置方式,就是路径绝对路径,从/开始,如/etc,/etc/passwd相对路径,相对于当前路径,以./或是../开始的 三,linux基本命令操作1终端Linux终端仿真器Terminal连接终端工具xshelltty命令可以查看当前所属的虚拟终端 不同虚拟终端之间进行通讯 1echo xuegod &gt; /dev/pts/0 在第2个终端上输入,会在第一个终端上输出 对所有终端广播消息 1wall &quot;The system will be shut down in 10 minutes&quot; 2shellshell提供了用户和内核进行交互操作的一种接口,是一个命令解释器 通过type命令可以查看内部命令,在系统启动时,调入内存,执行效率高外部命令,是系统软件的功能,用户需要时从硬盘读入内存 命令提示符中的”#”是超级用户,$是普通用户查看当前系统支持的shell 1cat /etc/shells 查看当前系统使用的是哪个shell 1cat /etc/passwd 3命令基本格式格式: 12命令 [选项] [对象]` 命令:具体执行的命令 选项:分为-和–两种 对象:要处理的文件,目录,用户等资源 4命令提示符1[root@localhost ~]# root: 当前登录用户 localhost:主机名 ~: 当前所在目录 #:超级用户的提示符号 $:普通用户的提示符 5查询目录中的内容1ls [选项] [文件或者目录] 选项 -a: 显示所有文件,包括隐藏文件 -l: 显示详细信息 -d: 查看目录属性 -h: 人性化显示文件大小 -i: 显示idode号 -S 以文件的大小进行排序(大&gt;小) 6别名的使用6.1别名的使用 设置别名 1alias vimens33=&apos;vim /etc/sysconfig/network-scripts/ifcfg-ens33&apos; 使用别名 1vimens33 删除别名 1unalias vimens33 6.2别名永久生效 12341)当前用户永久生效,写入到当前用户家目录下将上面的内容写入到/root/.bashrc2)全局使用,所有用户都生效将上面内容写入到/etc/bashrc 都需要重新加载生效source 目录路径 7建立目录mkdir1mkdir -p [目录名] 选项 -p: 递归创建 8切换目录1cd [目录] 简化操作 cd ~ : 进入当前用户的家目录 cd ../.. : 进入上两级目录 cd - : 进入上次目录 cd . : 进入当前目录 扩展1相对路径 参照当前所在目录,进行查找cd ../usr/local/src/ 扩展2绝对路径 从根目录进行指定,一级一级进行递归查找.任何目录下,都能够进入到指定位置cd /etc/local/ 9创建空文件touch123touch 文件1 文件2 #批量创建文件touch files&#123;1..5&#125; #创建files1到files5 5个文件touch -d “20190101 21:30” file.txt #指定创建时间 10删除1234rm -rf [文件或者目录]选项-r: 删除目录-f: 强制删除 11复制命令1cp [选项] [源文件或目录] [目标目录] 选项 -r 复制目录 -p 连带文件属性目录 -d 若源文件是连接文件,则复制连接属性 -d 相当于-rpd 12剪切/重命名1mv [源文件或目录] [目标目录] 如果源文件和目标文件在同一目录下,就是重命名.否则就是移动 13硬链接vs软链接1ln [选项] [源文件] [目标文件] 选项 不加选项,创建硬链接 -s : 创建软链接 13.1硬链接特征(为一个文件又打开了一扇门) 1234拥有相同的i节点,和存储block,可以看做是同一个文件可以通过i节点识别不能跨分区不能针对目录使用 13.2软连接特征 12345类似window上的快捷方式软链接拥有自己的i节点,和存储block,但是数据块中只保存原文件的文件名和i节点号,并没有实际的文件数据软链接的文件权限为|rwxrwxrwx 用原文件的权限来限制软链接的权限修改任意文件,另一个都能改变删除原文件,软链接不能使用 14历史命令默认列出所有 1234history``` 查看最近的20条记录 history 20 12自定义保存数量 vi /etc/profile找到HISTSIZE字段,修改大小 12**历史命令常用方法 技巧1 光标上下键技巧2 ctrl+r &gt; 某命令的关键字 &gt; ctrl+r进行选择 &gt; 右光标键进行确认技巧3 键入时用空格来隐藏敏感数据历史 vi /etc/profile 中增加一个字段 HISTCONTROL=IGNORESPACE source /etc/profile 命令行键入时,在命令前面输入一个空格,这条命令记录不保存 12345###### 15时间管理&lt; 硬件时钟是指主板上的时钟设备,通常可在BIOS界面设定&lt; 系统时钟是指kernel中的时钟**15.1查看时间** 硬件时钟: hwclock系统时钟: date 12**15.2时区** UTC 世界标准时间GMT 格林尼治时间CST 中国标准时间 12**15.3显示自定义格式时间** date “+%Y-%m-%d %H:%M:%S” #年-月-日 时:分:秒date “+%F” #年-月-日 12**15.4设置指定时间** date -s “20200331 10:00:00” 12**15.5 -d显示字符串描述的时间,而不是当前时间** date -d “+1 months” +%F 123###### 16time测试时间命令time命令,测试一个命令运行的时间 time ls -l /etc/ 1234567time命令中的含义- real 实际使用时间- user 用户状态使用时间- sys 内核状态使用时间###### 17帮助命令&gt; 两种帮助查看命令man和--help man 命令命令 –help 1234567891011121314151617181920212223242526272829303132333435**17.1快捷键**|快捷键|解释|| --- | --- ||空格键|向下翻页||q|退出||PaGe down|向下翻页||PaGe up|向上翻页||home|到首页||end|到尾页||/|从上到下搜索某个关键字||? |从下往上搜索某个关键字||n | 查看下一个搜索到的关键字||N |查看上一个搜索到的关键字|**17.2文档中的结构**| 结构名称 | 翻译 || --- | --- | |NAME|名称||SYNOPSIS| 命令的大致使用说明||DESCRIPTION| 介绍说明||EXAMPLES| 演示||OVERVIEW| 概述||DEFAULTS| 默认的功能||OPTIONS| 具体的可用选项||ENVIRONMENT| 环境变量||FILES|用到的文件||SEE ALSO| 相关资料||HISTORY| 维护历史与联系方式|###### 18关机命令&gt; 关机命令比较多,这里只列举相对常用的shutdown&gt; shutdown 关机,重启,定时关机 shutdown [选项] [时间] 1234567891011选项- -h : 关机- -r : 重启- -c : 取消前一个命令时间- now : 立即- +10 : 10分钟之后- 10:00 : 十点钟常用的shutdown命令 shutdown -h now #立即关机shutdown -h +10 #10分钟之后关机shutdown -h 23:59 #指定时间关机shutdown -r 23:59 #指定时间重启 12###### 19系统运行级别 /etc/inittab0 系统停机模式,系统默认运行级别不能设置为0,会一直关机1 单用户默认,用于系统维护,禁止远程,类似windows下安全模式2 多用户模式,没有NFS和网络支持3 完整的多用户文本模式4 系统未使用5 图形化模式,登陆后进入图形GUI界面6 重启模式,不能设为默认,会一直重启 1更改默认启动级别 init 0关机init 6重启init 3进入字符界面init 5进入图形界面 1**查看当前启动级别** runlevelN 3 #输出结果为系统上一次运行级别,和当前级别 1234centos7已经不再使用/etc/inittab文件进行的默认启动级别配置而是使用了比sysinit的运行级别更为自由的target代替**设置默认第3启动级别** systemctl set-default multi-user.target 12**设置默认第5启动级别** systemctl set-default graphical.target 12**查看当前默认启动级别** systemctl get-default 12###### 20退出登录命令 logout 12345 - 通过ssh远程连接时,会经常用到###### 21临时切换到中文语言linux系统中通过LANG来切换语言临时改为中文 [root@localhost ~]# LANG=”zh_CN.UTF-8” 1临时改为英文 [root@localhost ~]# LANG=”en_US.UTF-8” 123456&gt; 当然也可以直接修改文件,那这样就是永久的了###### 22上传下载文件&gt; 通过远程工具上传下载文件安装lrzsz工具 [root@localhost ~]# yum install lrzsz 12该工具有两个命令**上传** rz 1**下载** sz /etc/passwd 1234###### 23查看上一个命令是否执行成功&gt; 0:上一个命令执行成功&gt; 1:上一个命令执行失败 [root@localhost nginx-1.16.0]# echo $?0 12###### 扩展:服务器操作**1设置服务器来电后自动开机** BIOS中,选择Integrated Peripharals中的SuperIO Device,将其中的Restore On Ac Power Loss 选项改为Power ON其中选项Last Start的意思的服务器来电之后,机器会恢复到断点之前的状态 12**2设置服务器定时开机** BIOS中,选择Power Management Setup ,就进入到了电源管理配置,选择wake Up Event Setup,找到RTC Alarm(报警)将Disabled改为Enabled,然后在下面设置Every day(每一天)的06:00:00 **f10 保存**]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-权限管理]]></title>
    <url>%2F2019%2F06%2F16%2Flinux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[权限管理1文件的基本权限1.1基础权限 root拥有最高权限 1-rw-r--r-- 1 root root 1548 May 7 00:18 /etc/passwd - rw- r– r– root root time filename 文件类型 拥有者权限 所属组权限 其他人的权限 拥有者 属组 最后修改时间 对象 其中文件类型|文件类型|解释||-|-||p|管道文件||d|目录||l|链接文件||-|普通文件||s|socket套接口文件.比如我们启用mysql时,会产生一个mysql.sock文件||c|表示字符设备文件||b|表示块设备文件| 权限| 权限 | 对文件来说 | 对目录来说 || - | - | - ||r|读|读(看目录里面有什么)||w|写|在目录里面操作文件||x|执行|进入目录| 常用的几种文件权限组成|权限|说明||-|-|| -rwx — — | 文件所有者对文件具有读取,写入和执行的权限|| -rw- r– r– | 文件所有者具有读,写的权限,用户组里用户和其他用户具有读取的权限|| -rw- rw- r-x | 文件所有者和同组里用户对文件具有读写的权限,其他用户仅具有读取和执行的权限|| drwx –x –x | 目录所有者具有读写和进入目录的权限,其他用户仅能进入该目录,却无法读取任何数据|| drwx — — | 除了目录所有者具有完整权限外,其他用户对该目录完全没有任何权限| 更改文件的属主和属组 chown 用来改变文件或者目录的属主 chgrp 可以用来改变文件或目录的默认属组(不常用) 参数-R,递归修改目录下的所有文件,修改目录时用 更改属主chown user filename更改属主和属组chown user:group filename更改属组chown :group filename 例 123[root@meditation sunlizhao]# lltotal 0-rw-rw-r-- 1 sunlizhao sunlizhao 0 Jun 24 21:49 test.sh 更改属主 1234[root@meditation sunlizhao]# chown root test.sh [root@meditation sunlizhao]# lltotal 0-rw-rw-r-- 1 root sunlizhao 0 Jun 24 21:49 test.sh 更改属主和属组 123[root@meditation sunlizhao]# chown sunlizhao:root test.sh [root@meditation sunlizhao]# ll test.sh -rw-rw-r-- 1 sunlizhao root 0 Jun 24 21:49 test.sh 更改属组 123[root@meditation sunlizhao]# chown :sunlizhao test.sh [root@meditation sunlizhao]# ll test.sh -rw-rw-r-- 1 sunlizhao sunlizhao 0 Jun 24 21:49 test.sh 一个文件只有读的权限,拥有者可以修改这个文件吗?文件所有者一定可以写文件1切换到属主,查看权限 1234[root@meditation sunlizhao]# su sunlizhao[sunlizhao@meditation ~]$ lltotal 0-r--r--r-- 1 sunlizhao sunlizhao 0 Jun 24 21:49 test.sh 2发现没有权限,尝试使用vim进行写如内容:qqq.并强制保存退出:wq! 1234[sunlizhao@meditation ~]$ cat test.sh [sunlizhao@meditation ~]$ vim test.sh [sunlizhao@meditation ~]$ cat test.sh qqq 修改文件,目录的权限语法:chmod [对谁操作] [操作符] [赋予什么权限] 文件名 对谁操作 解释 u 用户user,表示文件或目录的所有者 g 用户组group,表示文件或目录的所属用户组 o 其他用户others a 所有用户 作符号 解释 + 添加权限 - 减少权限 = 直接给定一个权限 例 123[root@meditation sunlizhao]# lltotal 4-r--r--r-- 1 sunlizhao sunlizhao 4 Jun 24 22:15 test.sh 赋予文件的所有者和所属组只有读和写权限 1234[root@meditation sunlizhao]# chmod ug=rw test.sh [root@meditation sunlizhao]# lltotal 4-rw-rw-r-- 1 sunlizhao sunlizhao 4 Jun 24 22:15 test.sh 赋予文件其他用户执行权限 1234[root@meditation sunlizhao]# chmod o+x test.sh [root@meditation sunlizhao]# lltotal 4-rw-rw-r-x 1 sunlizhao sunlizhao 4 Jun 24 22:15 test.sh 八进制修改权限 权限 二进制 八进制 描述 — 000 0 没有任何权限 –x 001 1 只有执行权限 -w- 010 2 只有写入权限 -wx 011 3 有执行和写入权限 r– 100 4 只有读取权限 r-x 101 5 有读取和执行权限 rw- 110 6 有读取和写入权限 rwx 111 7 有全部权限 rwx的权限分别是4,2,1 .使用计算后的数值. 比如rwxr-x–x用751来表示 1.2补码 为什么我们创建的文件的权限默认是644呢?我们创建文件的默认权限是怎么来的呢 umask命令允许设定文件创建时的缺省模式 永久更改:修改配置文件中的umask值 /etc/profile ~/.bash_profile ~/.profile 1234567[root@meditation ~]# vim /etc/profile if [ $UID -gt 199 ] &amp;&amp; [ &quot;`/usr/bin/id -gn`&quot; = &quot;`/usr/bin/id -un`&quot; ]; then umask 002 else umask 022 fi UID大于199且用户的组名和用户名一样,那么umask值为002,否则为022普通用户一般umask值为022 计算方法 文件默认权限是666 目录默认权限是777 666-022=644 777-022=755 这是一个好的记忆方法,但是不严谨.设置为033就会出错 正确的计算方法是1, 将默认权限(目录777,文件666)和umask值都转换为2进制2, 对umask取反3, 将默认权限和umask取反后的值 做与运算4,将得到的二进制再转换为8进制,即为权限 例子:umask为033 1234567文件默认权限666的二进制为110 110 110 #1转换2进制umask值为033的二进制为000 011 011umask值得二进制取反为111 100 100 #2umask二进制后取反110 110 110 和 111 100 100做与运算得到110 101 101 #3 与运算110 101 101 #4转成8进制,得到权限6 4 4 临时配置123456[root@meditation ~]# umask 044[root@meditation ~]# touch text.sh[root@meditation ~]# mkdir text[root@meditation ~]# ll text.sh -d textdrwx-wx-wx 2 root root 4096 Jun 24 23:42 text-rw--w--w- 1 root root 0 Jun 24 23:41 text.sh 666-044=622777-044=533 2特殊权限文件的特殊权限|suid | sgid | sticky ||-|-|-||u+s|g+s|o+t| SUID只能设置在二进制可执行程序上面.对目录设置无效功能:程序运行时的权限从执行者变更为 程序所有者的权限例子 1234[root@meditation ~]# which passwd/usr/bin/passwd[root@meditation ~]# ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27832 Jun 10 2014 /usr/bin/passwd SUID属性一般用在可执行文件上,当用户执行该文件时,会临时拥有该执行文件的所有者权限当我们使用passwd时,会获得所有者root的权限比如普通用户用passwd修改密码.其实根本没有权限去修改/etc/shadow文件.也是在使用passwd修改时,获得的权限 例:为less增加权限,可以在普通用户下执行获得所有者root的权限 123456789[sunlizhao@meditation ~]$ less /etc/shadow/etc/shadow: Permission denied[sunlizhao@meditation ~]$ su rootPassword: [root@meditation sunlizhao]# chmod u+s /usr/bin/less[root@meditation sunlizhao]# su - sunlizhaoLast login: Tue Jun 25 00:34:59 CST 2019 on pts/0[sunlizhao@meditation ~]$ less /etc/shadowsunlizhao:$1$ovE1KmR/$VjboKPTHp83/K5q8UqdgF.:18022:0:99999:7::: SGID即可以给二进制可执行程序设置,也可以给目录设置功能,在设置了SGID权限的目录下简历文件时,新创建的文件的所属组会继承上级目录的权限 例:为目录设置SGID权限后,更改GID.在目录下创建文件,发现GID继承上级目录 123456789[root@meditation sunlizhao]# mkdir test10[root@meditation sunlizhao]# chmod g+s test10/[root@meditation sunlizhao]# chown :bin test10/[root@meditation sunlizhao]# ll -d test10/drwxr-sr-x 2 root bin 4096 Jun 25 00:45 test10/[root@meditation sunlizhao]# touch ./test10/test.sh[root@meditation sunlizhao]# ll ./test10/test.sh -rw-r--r-- 1 root bin 0 Jun 25 00:48 ./test10/test.sh sticky只作用于目录功能: 目录下创建的文件只有root,文件创建者,目录所有者才能删除 文件扩展权限ACL例:设置用户sunlizhao对文件test.sht拥有rwx权限,sunlizhao用户不属于test.sh的所属主和组,又不想给other提权,该怎么做 12[root@meditation ~]# setfacl -m u:sunlizhao:rwx /tmp/test.sh [root@meditation ~]# 例2给目录加扩展权限(默认可以,不加d也可以) 123[root@meditation ~]# mkdir /tmp/test[root@meditation ~]# setfacl -m d:u:sunlizhao:rwx /tmp/test [root@meditation ~]# 例3给目录下所有文件增加扩展权限[root@meditation ~]# setfacl -R -m u:sunlizhao:rwx /tmp/test[root@meditation ~]# 去掉所有ACL权限 12345678910[root@meditation tmp]# lldrwxrwxr-x+ 2 root root 4096 Jun 25 01:21 test-rw-rwxr--+ 1 root root 5 Jun 25 01:18 test.sh[root@meditation tmp]# setfacl -b /tmp/test.sh [root@meditation tmp]# setfacl -b /tmp/test[root@meditation tmp]# lldrwxr-xr-x 2 root root 4096 Jun 25 01:21 test-rw-r--r-- 1 root root 5 Jun 25 01:18 test.sh 3创建一个root无法删除的文件 centos6开始有的 12345678chattr [选项] 文件选项+a 只能追加内容+i 系统不允许对这个文件进行任何的修改,如果是目录,那么只能修改目录下的文件,不允许建立和删除文件-a 取消a-i 取消ilsattr 查看]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-用户管理]]></title>
    <url>%2F2019%2F06%2F16%2Flinux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户与组 用户一般来说是指使用计算机的人,用户可以使用名称来登录计算机.除了人之外,一些系统服务器也需要含有部分特权的用户账户运行.因此出于安全考虑,用户管理应运而生,加以明确限制各个用户账户的权利.root在计算机中拥有至高权限,所以一般只作管理用,非特权用户可以通过SU或者SUDO程序来临时获得特权 用户类型 解释 UID 超级用户 root UID=0 普通用户 1系统用户 centos6UID:1-499 ; centos7UID:1-999 2本地用户 centos6UID:500+ ; centos7UID:1000+ 虚拟用户 伪用户 一般不会用来的登录系统,主要用于维持某个服务的正常运行 UID:每个用户的身份标识,类似于人的身份证号码用户和组的关系 一对一 一对多 多对一 多对多 配置文件 配置文件 作用 /etc/passwd 用户配置文件.记录每个用户的基本信息,并且对所有用户可读,每一行记录对应一个用户,每行记录通过冒号分隔 /etc/group 用户组文件.用户组的所有信息存放地,组名不能重复 /etc/shadow 用户对应的密码信息,因为passwd文件对所有用户都是可读的,为安全起见,把密码从passwd中分离出来放入这个单独的文件,该文件只有可读权限,从而保证密码安全性 /etc/passwd 1234567891011121314[root@localhost ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologin...每个字段解释用户名;密码占位符;UID;GID;用户描述;用户主目录;登录后使用的shell /etc/group 123456789101112131415[root@localhost ~]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:tty:x:5:disk:x:6:lp:x:7:mem:x:8:kmem:x:9:...字段解释组名:x:GID:(当前组中的用户) /etc/shadow 123456789101112131415161718192021222324[root@localhost ~]# cat /etc/shadowroot:$6$8DLTLutUGU6/s0BC$O/oTIS6Jo5pBHOfouJRC8ph.x/KDZh2HDibV6Py.VCD7rNxsVz8nEi7rK3UFrZrE1fVw5MFLTZeoqDS48D.QM0::0:99999:7:::bin:*:17834:0:99999:7:::daemon:*:17834:0:99999:7:::adm:*:17834:0:99999:7:::lp:*:17834:0:99999:7:::...参数解释:用户名;被加密后的密码;最近更改密码的日期,从19700101开始计算,69年UNIN出现的,1970/1/1/开始计算;密码不能更改的天数,0表示随时可以更改;密码过期时间,多少天后必须更改;密码需要更改的前七天发出警告;宽限天数,密码过了几天后还能更改密码;账号过期时间;保留;密码加密.分为三个部分第一部分表示使用哪种哈希算法 $1表示MD5,$6表示SHA-512 $5表示SHA-256第二部分用于加密哈希的salt第三部分是已加密的哈希 用户管理命令添加用户useradd -u &quot;UID&quot; -g &quot;初始组&quot; -G &quot;附加组&quot; -s &quot;登录的shell&quot; 用户 1添加harry用户 此命令会自动创建harry组,并成为该用户的主组,同时默认登录的shell是bash 12345[root@localhost ~]# useradd harry[root@localhost ~]# tail -1 /etc/passwdharry:x:1000:1000::/home/harry:/bin/bash[root@localhost ~]# id harryuid=1000(harry) gid=1000(harry) groups=1000(harry) 2创建harry1用户,指定UID为1100 123[root@localhost ~]# useradd -u 1100 harry1[root@localhost ~]# id harry1uid=1100(harry1) gid=1100(harry1) groups=1100(harry1) 3创建harry2用户,指定家目录 12345[root@localhost ~]# useradd -d /opt/harry2 harry2[root@localhost ~]# ls /opt/harry2[root@localhost ~]# id harry2uid=1101(harry2) gid=1101(harry2) groups=1101(harry2) 4创建harry3用户,不创建家目录 12345[root@localhost ~]# useradd -M harry3[root@localhost ~]# ls /home/harry harry1[root@localhost ~]# id harry3uid=1102(harry3) gid=1102(harry3) groups=1102(harry3) 5创建harry4用户,指定主组harry 123[ root@localhost ~]# useradd -g harry harry4[root@localhost ~]# id harry4uid=1103(harry4) gid=1000(harry) groups=1000(harry) 6创建harry5用户,指定附属组harry,harry1 1234[root@localhost ~]# useradd -G harry,harry1 harry5[root@localhost ~]# id harry5uid=1104(harry5) gid=1104(harry5) groups=1104(harry5),1000(harry),1100(harry1)[root@localhost ~]# 创建用户的另一命令adduser,两者没有任何区别.是useradd的软链接 1234[root@localhost ~]# which adduser/usr/sbin/adduser[root@localhost ~]# ll /usr/sbin/adduser lrwxrwxrwx. 1 root root 7 Jun 1 02:55 /usr/sbin/adduser -&gt; useradd 添加密码1 passwd harry1 交互式创建密码 123456[root@localhost ~]# passwd harry1Changing password for user harry1.New password: BAD PASSWORD: The password is shorter than 8 charactersRetype new password: passwd: all authentication tokens updated successfully. 2 echo 123456 | passwd –stdin harry1 免交互 123[root@localhost ~]# echo 123456 | passwd --stdin harry2Changing password for user harry2.passwd: all authentication tokens updated successfully. 删除用户userdel -r harry5 123[root@localhost ~]# userdel -r harry5[root@localhost ~]# userdel -r harry4[root@localhost ~]# userdel -r harry3 选项-r 删除的时候,会同时删除用户的家目录和/var/mail下的目录 扩展1,模板文件被删除之后显示不正常的问题 shell提示符不完整 12345678910111213[root@localhost ~]# rm -rf /home/harry1/.bash*[root@localhost ~]# su - harry1Last login: Sat Jun 1 04:53:22 CST 2019 on pts/1-bash-4.2$ -bash-4.2$ exitlogout[root@localhost ~]# cp /etc/skel/.bash* /home/harry1/[root@localhost ~]# chown harry1:harry1 /home/harry1/.bash*[root@localhost ~]# su - harry1Last login: Sat Jun 1 04:54:15 CST 2019 on pts/1[harry1@localhost ~]$ exitlogout[root@localhost ~]# 扩展2,忘记root密码,怎样找回呢1开机在选择内核的界面处,按”e” 2修改ro为 rw init=/sysroot/bin/sh 3按ctrl+x保存:进入紧急模式]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>用户管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-计划任务]]></title>
    <url>%2F2019%2F06%2F16%2Flinux-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[计划任务 做一些周期性的任务,在生产中主要定时备份数据 任务调度级别分为: 用户任务调度 系统任务调度 计划任务的方式分为两种 at —– 突发性,临时决定的,只执行一次的任务 arontab —– 定时性,例行,每隔一定的周期重复执行 at安装at 1[root@localhost ~]# yum install at 启动atd服务 123456[root@localhost ~]# systemctl start atd[root@localhost ~]# systemctl status atd● atd.service - Job spooling tools Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2019-06-01 20:19:06 CST; 4s ago Main PID: 7404 (atd) 设置atd任务 1234[root@localhost ~]# at 12:35at&gt; mkdir /opt/hhhat&gt; &lt;EOT&gt;job 4 at Sat Jun 1 12:35:00 2019 处通过ctrl+d保存退出 设置atd任务的其他指定时间方式 1234at 20:00 2018-10-1 在某一天at now +10min 在10分钟之后执行at 17:00 tomorrow 明天下午5点执行at 6:00 pm +3 days 在三天以后的下午6点执行 查看是否生效 12345678[root@localhost ~]# dateSat Jun 1 12:34:47 CST 2019[root@localhost ~]# ls /opt/[root@localhost ~]# dateSat Jun 1 12:35:17 CST 2019[root@localhost ~]# ls /opt/hhh 查看所有任务(atq | at -l) 12345678[root@localhost ~]# at 20:00 2019-06-01at&gt; mkdir /opt/testat&gt; &lt;EOT&gt;job 7 at Sat Jun 1 20:00:00 2019[root@localhost ~]# atq7 Sat Jun 1 20:00:00 2019 a root[root@localhost ~]# at -l7 Sat Jun 1 20:00:00 2019 a root 查看具体任务的内容,需要使用上面查看的编号 123456[root@localhost ~]# at -c 7...$&#123;SHELL:-/bin/sh&#125; &lt;&lt; &apos;marcinDELIMITER11f8e4d7&apos;mkdir /opt/testmarcinDELIMITER11f8e4d7 或者可以查看这些任务存放位置(没有执行过的任务) 1/var/spool/at/ 删除计划任务 123[root@localhost ~]# atrm 7[root@localhost ~]# atq[root@localhost ~]# crontab启动服务 123456[root@localhost ~]# systemctl start crond[root@localhost ~]# systemctl status crond● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2019-06-01 19:49:40 CST; 6h left Main PID: 3933 (crond) 常用参数 1234567crontab -e 编辑cron任务crontab -r 删除cron任务crontab -u mk 指定mk用户的cron服务crontab -l 列出当前用户的cron服务的详细内容crontab -u root -l 列出指定用户的cron计划任务crontab -u mk -r root删除mk用户的cron计划任务 -e编辑时的语法| |1|2|3|4|5|6||-|-|-|-|-|-|-||符号| * | * | * | * | * | * ||解释|分钟|小时|几号|月份|星期几|command||取值范围|0-59|0-23|1-31|1-12|0-6|command| 特殊符号含义|符号|含义|举例||-|-|-|| * |代表取值范围内的任意数字|任意 / 每一天|| / |指定时间的间隔频率| */10|| - |代表从某个数字到某个数字|8-17|| , |分开离散的几个数字|6,12-18,21| 测试: 每分钟写入hhhh到该文件 12[root@localhost ~]# crontab -e* * * * * echo &quot;hhhh&quot; &gt;&gt; /opt/echo.txt 过一段时间查看 123[root@localhost ~]# cat /opt/echo.txt hhhhhhhh 每天凌晨2点1分备份数据 12[root@localhost ~]# crontab -e1 2 * * * tar zcvf /opt/grub2.tar.gz /boot/grub2 指定用户查看计划任务 123[root@localhost ~]# crontab -u root -l1 2 * * * tar zcvf /opt/grub2.tar.gz /boot/grub2* * * * * echo &quot;hhhh&quot; &gt;&gt; /opt/echo.txt 如果别人通过某一个用户写入计划任务,但是我们不知道是哪一用户,该如何排查呢 1[root@localhost ~]# crontab -u bin -e 所有用户的计划任务,都会在/var/spool/cron/下产生相应的文件 12[root@localhost ~]# ls /var/spool/cron/bin root 系统级别的计划任务系统任务调度的配置文件/etc/crontab 123456789101112131415[root@localhost ~]# cat /etc/crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 可以在文件后加入 1* * * * * root echo &quot;hhhh&quot; &gt;&gt; /opt/echo.txt /etc/cron.d/ 是系统自动定期需要做的任务,但是又不是按照小时,天,星期,月来执行的,那就放在这个目录下面cron.deny 控制]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>定时执行计划</tag>
        <tag>计划任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-软件管理]]></title>
    <url>%2F2019%2F06%2F16%2Flinux-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[软件管理通常而言,可以通过后缀区别源码包和二进制包 以.rpm .deb结尾的软件包称之为二进制包,已经通过GCC编译后的 以.tar .tar.gz .zip .rar 结尾称为源码包,需要编译 目录 12345678二进制包 rom包管理 yum包管理 源码包 tar包管理 文件的管理和归档 1二进制包1.1rpm软件包管理 centos操作系统中有一款默认软件管理的工具,即红帽包管理工具(red hat package manager , RPM) rpm使用时,什么情况下使用软件包全名,什么时候使用软件包名? 包全名:对安装和更新升级时使用 包名:对已经安装过的软件包进行操作时,比如查找已经安装的某个包,卸载包等,使用包名(默认是去目录/var/lib/rpm下进行搜索.当一个rpm包安装到系统上之后,安装信息通畅会保存到本地) 安装选项 -i install的意思,安装软件包 -v 显示附加信息,提供更多详细信息 -h 安装时输出######标记 1,挂载光盘 1[root@localhost ~]# mount /dev/cdrom /mnt 2,安装 1[root@localhost ~]# rpm -ivh /mnt/Packages/zsh-5.0.2-31.el7.x86_64.rpm 3,查看是否安装成功 123456[root@localhost ~]# cat /etc/shells/bin/sh/bin/bash/usr/bin/sh/usr/bin/bash/bin/zsh 查询rpm -q 查询. 常与下面参数组合使用. -a 查询所有已经安装的软件包 -f 查询 文件所属哪个软件包,反向查询 -i 显示已经安装的rpm软件包信息,后面直接跟包名 -l 查询软件包中,文件安装的位置 -p 查询未安装软件包的相关信息,后面要跟软件的命名 -R 查询软件包的依赖性 -q 查询指定的包是否安装 12[root@localhost ~]# rpm -q zshzsh-5.0.2-31.el7.x86_64 -qa 查询所有已经安装包 12[root@localhost ~]# rpm -qa | grep vivim-minimal-7.4.160-5.el7.x86_64 -qf 查询文件或命令属于哪个安装包 1234[root@localhost ~]# which ifconfig/usr/sbin/ifconfig[root@localhost ~]# rpm -qf /usr/sbin/ifconfig net-tools-2.0-0.24.20131004git.el7.x86_64 -qpi 查询软件包的信息 12345678910# 对于未安装的包[root@localhost ~]# rpm -qpi /mnt/Packages/php-mysql-5.4.16-46.el7.x86_64.rpm Name : php-mysqlVersion : 5.4.16对于已经安装的包[root@localhost ~]# rpm -qi net-toolsName : net-toolsVersion : 2.0Release : 0.24.20131004git.el7 -qpl 查询软件包要安装的位置 123456789101112131415对于未安装的包[root@localhost ~]# rpm -qpl /mnt/Packages/net-tools-2.0-0.24.20131004git.el7.x86_64.rpm /bin/netstat/sbin/arp/sbin/ether-wake/sbin/ifconfig/sbin/ipmaddr/sbin/iptunnel对于已经安装的包[root@localhost ~]# rpm -ql net-tools/bin/netstat/sbin/arp/sbin/ether-wake/sbin/ifconfig 校验-qf 查看软件包内容是否被修改,用于检验命令没有被黑客修改 1234567[root@localhost ~]# which find/usr/bin/find[root@localhost ~]# rpm -qf /usr/bin/findfindutils-4.5.11-6.el7.x86_64[root@localhost ~]# rpm -V findutils #检查包,没有输出结果就是没有被修改[root@localhost ~]# rpm -Vf /usr/bin/find #检查具体文件,没有输出结果就是没有被修改 如何查看系统中所有的rpm包及安装的文件有没有被黑客修改? 1234[root@localhost ~]# rpm -Va.M....... g /boot/initramfs-3.10.0-957.el7.x86_64.imgS.5....T. c /etc/sysconfig/authconfig校验时候参考了/var/lib/rpm目录下的rpm数据库信息 卸载和升级卸载 123[root@localhost ~]# rpm -e zsh[root@localhost ~]# rpm -qa | grep zsh[root@localhost ~]# 强制卸载 不建议使用.有依赖关系是建议使用yum来卸载 1[root@localhost ~]# rpm -e --nodeps zsh 升级 因为升级时候会有一些依赖包要解决,所以一般我们使用(yum update 包),来升级 1rpm -Uvh 1.2 yum软件管理程序 yellow dog updater,Modified 基于RPm包管理,能够从指定的服务器自动下载RPM包并且安装,可以自动处理依赖性关系,并且一次安装所有以来的软件包.基于c/s架构 yum提供了查找,安装,删除某一个,一组甚至全部软件包的命令 1本地yum源1挂载光盘 1mount /dev/cdrom /mnt 2备份配置文件 12[root@localhost ~]# mv /etc/yum.repos.d/ /etc/yum.repo.d[root@localhost ~]# mkdir /etc/yum.repos.d 3创建yum本地源 123456[root@localhost ~]# vim /etc/yum.repos.d/centos7.repo #名称任意,但是一定要.repo结尾[centos7] #yum源名称,在本服务器上是惟一的name=centos7 #yum源描述信息baseurl=file:///mnt #yum源的路径(ftp://... HTTP://... file:///...)enabled=1 #1启用yum源 , 0为禁用gpgcheck=0 #1使用公钥校验rpm包的正确性,0为不校验 4清除yum缓存 123[root@localhost ~]# yum clean allLoaded plugins: fastestmirrorCleaning repos: centos7 2配置网络源1下载阿里yum源并保存到指定路径 wget 下载. -O指定保存位置 1[root@localhost ~]# wget -O /etc/yum.repos.d/CentOS.Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 2清除yum缓存 1[root@localhost ~]# yum clean all 3当centos推出新版本的系统后,yum源不能用了该怎么办呢?12cat /etc/yum.repos.d/CentOS.Base.repobaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ 其中$releasever代表的是系统版本 12[root@localhost ~]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core) 自动识别本地系统版本,和网站中的最新的版本对应.所以应该更改配置文件中的版本信息 1234561 查看 发现网站中http://mirrors.aliyun.com/centos/ centos版本最新的是7.6.18102 替换[root@localhost ~]# sed -i &apos;s/$releasever/7.6.1810/g&apos; /etc/yum.repos.d/CentOS.Base.repo 3更新[root@localhost ~]# yum clean all yum常用操作安装和升级 1234yum install -y httpd #安装软件包yum update httpd #升级软件包,改变软件设置和系统设置,系统版本内核都升级yum upgrade httpd #升级软件包,不改变软件设置和系统设置,系统版本升级,内核不改变yum -y update #系统内能升级的软件都会升级 检索 123yum info net-tools #查询rpm包的作用yum provides /usr/sbin/ifconfig #查询文件是哪一个软件安装的,同rpm -qfyum search vim #按照关键字搜索软件包 卸载 1yum remove zsh #卸载包 yum安装开发工具软件包组 12345查看有哪些软件包组[root@localhost ~]# yum grouplist安装开发工具组[root@localhost ~]# yum groupinstall &quot;Development Tools&quot; 源码包源码安装Nginx安装1安装依赖 1[root@localhost ~]# yum -y install gcc gcc-c++ make zlib-devel pcre pcre-devel openssl-devel 2解压 1[root@localhost ~]# tar zxvf nginx-1.16.0.tar.gz 3安装软件 1234[root@localhost ~]# cd nginx-1.16.0[root@localhost nginx-1.16.0]# ./configure --prefix=/usr/local/nginx[root@localhost nginx-1.16.0]# make -j 4 [root@localhost nginx-1.16.0]# make install 详解./configure 可以指定安装路径,例如 –prefix=/usr/local/nginx 启用或者禁用某项功能 检查安装环境 最终生成:Makefile make -j 4 按Makefile文件编译 通过4核心CPU来完成 make install 按Makefile定义的文件路径安装 make clean 当我们想指定安装路径,这时就需要删除上次生成的Makefile. 或者可以删除源码包,重新解压. 删除源码包1make uninstall 但是很多时候删除不干净所以一般安装时指定路径–prefix=/usr/local/nginx这样进行操作时,可以直接对这个路径进行操作 错误解决方法1can&apos;t find ext2fs library 根据提示,安装ext2fs库 一般我们可以RPM安装,通过按tab键补齐.不行的话可以查找关键字 12345[root@localhost ~]# rpm -ivh /mnt/Packages/ext2fs[root@localhost ~]# ls /mnt/Packages/*ext2fs*[root@localhost ~]# ls /mnt/Packages/*2fs*/mnt/Packages/e2fsprogs-libs-1.42.9-13.el7.i686.rpm/mnt/Packages/e2fsprogs-libs-1.42.9-13.el7.x86_64.rpm 还可以通过yum search ext2fs来检索 1[root@localhost ~]# yum search ext2fs 当我们把库已经安装,但是configure时又说找不到,怎么办 我们还需要安装该库的头文件 1/mnt/Packages/e2fsprogs-devel-1.42.9-13.el7.x86_64.rpm 总结 rpm+yum:方便,软件版本低,稳定性好,管理方便 源码编译:麻烦,软件版本新,可以定制,稳定性和管理稍差,但是性能好 一般LAMP或LNMP架构时,我们会用源码 文件的归档和压缩 好处:节约硬盘的资源,加快文件传输速率 tar命令:打包文件选项 -c 创建压缩包 -x 解压还原文件 -v 显示执行详细过程 -f 指定文件 -t 不解包,查看包中的内容 -C 指定解压位置 把/boot/grub/打包到指定路径 123[root@localhost ~]# tar -cvf /home/harry1/grub.tar /boot/grub//boot/grub//boot/grub/splash.xpm.gz 解包grub.tar到指定路径 123[root@localhost ~]# tar xvf grub.tar boot/grub/boot/grub/splash.xpm.gz 将多个目录和文件打包成一个软件包 1234[root@localhost ~]# tar -cvf /home/harry1/back.tar /etc/passwd /etc/group /home/harry1//etc/passwd/etc/group/home/harry1/ 不解包,只查看包中的内容 1234[root@localhost ~]# tar -tvf /home/harry1/back.tar -rw-r--r-- root/root 941 2019-06-05 05:17 etc/passwd-rw-r--r-- root/root 519 2019-06-05 05:17 etc/group... 在使用绝对路径名归档文件时,默认从文件名中删除该路径前面的/符号,这样解压时,会直接解压到当前目录.不然会覆盖原路径中的文件 归档+压缩参数 -z 以gzip方式压缩 扩展名tar.gz -j 以bz2方式压缩 扩展名tar.bz2 -J 以xzx方式压缩 扩展名tar.xz tar.gzip 1234压缩[root@localhost ~]# tar zcvf /home/harry1/etc.tar.gz /etc解压缩[root@localhost ~]# tar zxvf /home/harry1/etc.tar.gz -C /opt/ tar.bz2 1234压缩[root@localhost ~]# tar jcvf /home/harry1/etc.tar.bz2 /etc解压缩[root@localhost ~]# tar jxvf /home/harry1/etc.tar.bz2 -C /opt/ tar.xz 1234压缩[root@localhost ~]# tar Jcvf /home/harry1/etc.tar.xz /etc解压缩[root@localhost ~]# tar Jxvf /home/harry1/etc.tar.xz -C /opt/ 经过测试,解压缩时如果存在相同文件,会直接覆盖,不会询问 效果 r &lt; tar.gzip &lt; tar.bz2 &lt; tar.xz ,所用的时间越长]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>yum本地源</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过git+hexo+github搭建个人站点]]></title>
    <url>%2F2019%2F06%2F16%2F%E9%80%9A%E8%BF%87git%2Bhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[通过git+hexo+github搭建个人站点 git：分布式版本控制系统，在这里的作用是，通过git工具将hexo生成的页面部署到gitee上的个人站点 hexo：Hexo 是一个快速、简洁且高效的博客框架。 github：GitHub是最大的开源代码托管平台,旨在促进在一个共同项目上工作的个人之间的代码托管、版本控制和协作。 1安装git相关工具 需要安装git和node.js工具 安装git https://git-scm.com 1开始安装 2选择安装路径 3选择安装组件 4菜单文件夹 5git使用的默认编辑器 6调整环境变量 7选择http传输 8配置行尾结束符号 9配置终端仿真 10其他配置，默认就好 测试是否安装完成（cmd命令行） 安装node.js https://nodejs.org1开始安装 2协议 3安装路径 4默认安装4项 5安装 6安装完成 7测试是否安装成功 2安装hexo，并生成本地站点1右击打开Git Bash Here 12inmeditation@DESKTOP-029SIEV MINGW64 ~/Desktop$ 2安装hexo 1$ npm install -g hexo-cli 3指定文件夹并安装所需要的文件 123$ hexo init hexob$ hexo cd hexob$ npm install 4启动本地网站 12$ hexo g$ hexo s 5浏览器预览网站 1 http://localhost:4000 3配置next主题 命令都是在hexod目录下执行 1下载next主题 在hexo官方网站点击主题名称,跳转到github下载页面,复制页面提供的下载链接将该主题下载至themes目录下 1$ git clone https://github.com/theme-next/hexo-theme-next.git ./themes/next 2启用next 修改/Desktop/hexob/_config.yml 1theme: next 3更改主题为中文 修改/Desktop/hexob/_config.yml 1language: zh-CN 4标签页和分类页 Desktop\hexob\themes\next_config.yml在首页添加 12345menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 5使标签和分类生效 5.1标签页生效 会在\hexob\source下创建\tags\index.md 1$ hexo n page tags 编辑该文件\tags\index.md 12345---title: 标题date: 2019-06-15 23:29:21type: &quot;tags&quot;--- 5.2分类页生效 会在\hexob\source下创建\categories\index.md 1$ hexo n page categories 编辑categories\index.md 123456---title: 分类date: 2019-06-15 23:37:11type: categories--- 6更改主题样式 Desktop\hexob\themes\next\ _config.yml 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 7设置头像 200* 200照片存放位置:\Desktop\hexob\themes\next\source\images配置文件:Desktop\hexob\themes\next\ _config.yml 12avatar: url: /images/avatar.gif 8更改标题作者及链接 修改/Desktop/hexob/_config.yml 123title: INMEDITATIONauthor: sunlizhaourl: https://www.cnblogs.com/inmeditation 9启用侧边栏的社交链接 Desktop\hexob\themes\next\ _config.yml 12345social: 百度: https://www.baidu.com/ 博客园: https://www.cnblogs.com/ CSDN: https://www.csdn.net/ 李鑫snake: minisnake.cn/ 10启用友情链接 Desktop\hexob\themes\next\ _config.yml 12links: 自用: https://www.cnblogs.com/inmeditation 11新建一篇文章 文章存放目录Desktop\hexob\source_posts 1$ hexo n 测试文章 测试文章.md 中内容 12345678910111213---title: 测试文章date: 2019-06-16 00:13:29tags: - 导航 - 测试 - 分享categories: - 测试 ---### 文章内容 12开启文章的打赏功能 图片存放路径Desktop\hexob\themes\next\source\images配置文件Desktop\hexob\themes\next\ _config.yml 1234567reward_settings: enable: true animation: truereward: 微信: /images/wechatpay.png 支付宝: /images/alipay.png 13设置头像为圆形,可旋转\Desktop\hexob\themes\next\source\css_common\components\sidebar\sidebar-author.styl 1234567891011121314.site-author-image &#123; show(); margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; opacity: hexo-config(&apos;avatar.opacity&apos;) is a &apos;unit&apos; ? hexo-config(&apos;avatar.opacity&apos;) : 1; border-radius: 50%; #头像圆形 transition: 2s all; #旋转动画时间&#125;.site-author-image:hover&#123; transform: rotate(360deg); #旋转角度&#125; 14首页文章设置阅读全文 Desktop\hexob\themes\next\ _config.yml 123auto_excerpt: enable: true length: 80 15搜索功能Local Search 安装 1$ npm install hexo-generator-searchdb --save 站点配置文件中新加 12345search: path: search.xml field: post format: html limit: 10000 主题配置文件中启用 12local_search: enable: true 16不蒜子统计 主题配置文件 12345678busuanzi_count: enable: true site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次 17隐藏底部驱动 将改文件内,信息注释掉\Desktop\hexob\themes\next\layout_partials\footer.swig 123456789101112131415161718&lt;!--&#123;% if theme.footer.powered.enable %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, next_url(&apos;https://hexo.io&apos;, &apos;Hexo&apos;, &#123;class: &apos;theme-link&apos;&#125;)) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&apos;version&apos;) &#125;&#125;&#123;% endif %&#125;&#123;# #&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; &#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; – &#123;&#123; next_url(&apos;https://theme-next.org&apos;, &apos;NexT.&apos; + theme.scheme, &#123;class: &apos;theme-link&apos;&#125;) &#125;&#125;&#123;# #&#125;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; --&gt; 4部署1配置git 12$ git config --global user.name &quot;inmeditation&quot;$ git config --global user.email &quot;15053638991@163.com&quot; 2配置ssh公钥 2.1本地生成秘钥 1$ ssh-keygen -t rsa -C &quot;15053638991@163.com&quot; 2.2复制 1$ cat ~/.ssh/id_rsa.pub 2.3粘贴到站点 1https://gitee.com/profile/sshkeys 3测试公钥链接 1234$ ssh -T git@github.comHi sunlizhao31! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 4安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 5复制gitee仓库ssh地址到站点配置文件 1234deploy: type: git repo: git@gitee.com:inmeditation/inmeditation.git branch: master 6生成&amp;部署 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 7启动Gitee Pages 服务,即可访问 https://gitee.com/inmeditation/inmeditation/pages 1http://inmeditation.gitee.io/ 5绑定域名1,CNAME 文件配置 在hexob\source\下创建CNAME文件,存放自定义域名 1www.sunlizhao.cn 2,在域名购买处,设置解析 主机记录 记录类型 线路类型 记录值 MX优先级 TTL（秒） 最后操作时间 操作 www CNAME 境内 sunlizhao31.github.io. - 600 2019-06-27 19:53:32 修改暂停删除 @ A 境内 185.199.108.153 - 600 2019-06-27 20:12:26 修改暂停删除 3,GitHub Pages 在此处添加自定义域名]]></content>
      <categories>
        <category>lamp</category>
      </categories>
      <tags>
        <tag>网站</tag>
        <tag>个人站点</tag>
        <tag>绑定域名</tag>
      </tags>
  </entry>
</search>
